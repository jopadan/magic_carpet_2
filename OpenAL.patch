full diff between my 'OpenAL' branch and the upstream 'development' branch of the upstream repo at the time when the modifications were made.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 21f3e3b46..ef0cfe59b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -55,9 +55,9 @@ else()
     set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})
     #add_compile_options(-fpermissive)
     add_compile_options(-Wno-narrowing)
-    add_compile_options(-Wall)
-    add_compile_options(-Wextra)
-    add_compile_options(-pedantic)
+    #add_compile_options(-Wall)
+    #add_compile_options(-Wextra)
+    #add_compile_options(-pedantic)
     add_compile_options(-Wno-unknown-pragmas)
     if (USE_SANITIZERS)
         add_compile_options(-fsanitize=address)
diff --git a/README_OpenAL b/README_OpenAL
new file mode 100644
index 000000000..ef33e8e6a
--- /dev/null
+++ b/README_OpenAL
@@ -0,0 +1,36 @@
+
+About OpenAL
+
+    OpenAL is an API designed for rendering positional audio and environmental effects.
+    It's development started 4 years after the Magic Carpet's release, however I am certain that if the release dates would have been reversed then Bullfrog would have implemented this API in all their games.
+In MC2 the structures were ready to support left/right volume panning and there is an effort to decrease the volume for distant creatures. Fortunately they did not waste too much code trying to implement an in-house 3D positional sound system and were quite happy to simply provide arround 200 PCM sound samples that will end up being triggered during gameplay and rendered as mono sounds with just variable gain.
+
+runtime dependencies
+
+    linux needs the openal package installed. windows needs a driver called 'OpenAL x.y Windows Installer (zip)' available here: https://www.openal.org/downloads/
+
+OpenAL port
+
+    The ~200 samples can be divided into three main categories:
+      - creature-bound howls/squeals/screams/buzzing sound bytes. used by dragons, goats, bees, worms, wyverns, manticores, fireflies, spiders, devils, mana worms, moon dwellers, troglodites, cymmerians, zombies and hydras. these creature's positions are tracked frame-by-frame and if the listener is within AL_DIST_MIN_PLAY pixels distance then the associated sound chunk is sheduled to be played at random intervals. the initial sound's amplitude and the trigger interval is customized by the port, but the listener's left/right panning and the distance compensated acoustic attenuation is fully controlled by OpenAL.
+      - spells and some creature attacks. these are not tracked since they come with some distancing effects pre-applied. the sound source is placed at the listener's position at the time of when the sound sample was triggered. so if the player moves while being attacked then those samples will trail behind.
+      - environmental sounds (wind, markets, oceans, crickets, drips). these are triggered based on the area in which the player is flying. it makes little sense to set these as puctiform sound sources as for the previous categories, so they are converted to stereo before being fed to OpenAL. this means that no positional effect is applied and the player will hear these sounds with a constant volume which is controlled via config.ini:openal_environment_volume
+
+    Every PCM sound sample that can be heard is thus an OpenAL 'sound source'. the player is what the API calls a 'listener'. the listener's position and direction are updated every frame and we have seen that some sound sources get their position updated with the same frequency. once a sound is triggered by the scheduler or by the recode, a sound source is created and thus a play channel is used. it seems like most soundcards support up to about 30 concurrent sources (sometimes called 'voices'). in order to be able to hear a more diverse range of sounds, a limit of how many times one sample can be played concurrently is implemented and can be customized via config.ini:openal_same_chunk_concurrency. experimentation with this setting is welcome.
+
+    OpenAL's alternative to Creative EAX is called EFX. it can provide nice reverb effects for better game immersion. it can be enabled or disabled via the config.ini:openal_efx option.
+
+
+speech audio tracks
+
+    The Magic Carpet 2 game comes on a mixed-mode CD containing 28 tracks. The first track holds the game data in ISO9660 format, while the rest are audio tracks of a narrator voice-over that is triggered from time to time during gameplay. This port keeps them in the 'speech' directory, in raw form.
+    The problem is that GoG and most other sources provide flawed rips of these data tracks. So if you happen to hear short pop sounds while speech is enabled or if the speech is misaligned (it ends too soon), then either try to rip an original CD yourself (via the provided assets/scrips/check_install.sh script) or mix-and-match tracks from GoG and other sources. you can load these files into a sound editor like audacity (by importing them as raw data in little endian, 44100 stereo signed 16 bit pcm format) and simply identify the zones where digital noise has crept over the audio.
+
+    this is a list of audio tracks and their status on the GoG-provided image:
+
+    track#2              - no artefacts and perfectly aligned
+    track#3 - track#28   - all have noisy artefacts in the first 400 ms at the beginning of the track, so it is advised to obtain these tracks from a different rip.
+
+    enabling speech is as simple as providing a relative directory as config.ini:speech_folder.
+    it's volume level is controllerd by config.ini:openal_speech_volume (must be provided as an integer between 0 and 127). 0 completely disables the speech subsystem.
+
diff --git a/config.ini b/config.ini
index 7b6e51d91..07a908eb9 100644
--- a/config.ini
+++ b/config.ini
@@ -13,6 +13,12 @@ oggmusic = true ; using AWE32 record of MIDI music, for this function is hqsound
 oggmusicFolder = music-ogg ; directory with music, you can rewrite with own music too. Path is relative to .exe
 oggmusicalternative = true ; use original and alternative sound tracks
 fixspeedsound = false ; set true when sounds play double speed
+speech_folder = speech ; 
+openal_environment_volume = 48 ; // see README_OpenAL for a description. integer between 0 - 127 
+openal_speech_volume = 100 ; // see README_OpenAL for a description. integer between 0 - 127 
+openal_efx = true ; enable reverb effect
+openal_same_chunk_concurrency = 6 ; up to how many concurrent plays of a given sample should exist in any given moment
+
 
 [graphics]
 displayIndex = 0 ; Decides which display to use, if it cannot find a display at the index, it will find the first one big enough.
diff --git a/remc2/CMakeLists.txt b/remc2/CMakeLists.txt
index 7ab03f8d2..2ec6563bc 100644
--- a/remc2/CMakeLists.txt
+++ b/remc2/CMakeLists.txt
@@ -132,8 +132,11 @@ set(SOURCE_FILES__portability
     "portability/port_inputs.h"
     "portability/port_outputs.cpp"
     "portability/port_outputs.h"
+    "portability/port_sound_lut.h"
     "portability/port_sdl_sound.cpp"
     "portability/port_sdl_sound.h"
+    "portability/port_openal.cpp"
+    "portability/port_openal.h"
     "portability/port_sdl_vga_mouse.cpp"
     "portability/port_sdl_vga_mouse.h"
     "portability/port_sdl_joystick.cpp"
@@ -212,8 +215,10 @@ if (UNIX)
         SDL2::Mixer
         ${PNG_LIBRARY}
         findfirst
-        ADLMIDI_static
         Boost::system
+        spdlog
+        fmt
+        openal
     )
     target_link_directories(${PROJECT_NAME} PUBLIC
     )
diff --git a/remc2/engine/Sound.cpp b/remc2/engine/Sound.cpp
index 0333d51f1..949a4067a 100644
--- a/remc2/engine/Sound.cpp
+++ b/remc2/engine/Sound.cpp
@@ -1069,6 +1069,8 @@ void AilRestoreUSE16ISR_91E90(int32_t isr)
 //----- (00099C10) --------------------------------------------------------
 void EndSounds_99C10()//27ac10
 {
+	uint16_t i;
+
 	if (soundLoaded_E379A)
 	{
 		EndSample_8D8F0();
@@ -1079,8 +1081,17 @@ void EndSounds_99C10()//27ac10
 			FreeMem_83E80((uint8_t*)soundIndex_E37A0);
 			numOfLoadedSounds_E37A4 = 0;
 		}
-		if (soundBuffer1_E37A8)
+		if (soundBuffer1_E37A8) {
+			for (i = 0; i < hDigSoundEffectsDriver_180B48->n_samples_24; i++) {
+                if (hDigSoundEffectsDriver_180B48->samples_23[i].start_44mhz) {
+                    free(hDigSoundEffectsDriver_180B48->samples_23[i].start_44mhz);
+                }
+                if (hDigSoundEffectsDriver_180B48->samples_23[i].wavbuff) {
+                    free(hDigSoundEffectsDriver_180B48->samples_23[i].wavbuff);
+                }
+            }
 			FreeMem_83E80(soundBuffer1_E37A8);
+		}
 		soundAble_E3798 = false;
 		soundActive_E3799 = false;
 		soundLoaded_E379A = false;
@@ -1815,6 +1826,10 @@ bool LoadSound_84300(uint8_t soundIndex)//265300
 				DataFileIO::Close(file);
 				return true;
 			}
+#ifdef SOUND_OPENAL
+            alsound_clear_cache();
+            alsound_set_env(soundIndex, AL_SET_BANK);
+#endif
 			actualSound_E37AD = soundIndex;
 			DataFileIO::Close(file);
 		}
@@ -1887,19 +1902,17 @@ bool ReadAndDecompressSound(FILE* file, uint8_t soundIndex2)//2654f0
 	numOfLoadedSounds_E37A4 = (soundBank2[soundIndex2].sizeBytes_8) / sizeof(shadow_sub2type_E37A0_sound_buffer2);
 	DataFileIO::Seek(file, soundBank2[soundIndex2].dword_4, 0);
 	DataFileIO::Read(file, soundBuffer1_E37A8, 8);
-	if (soundBuffer1_E37A8[0] != 'R' || soundBuffer1_E37A8[1] != 'N' || soundBuffer1_E37A8[2] != 'C')
-	{
+	if (soundBuffer1_E37A8[0] != 'R' || soundBuffer1_E37A8[1] != 'N' || soundBuffer1_E37A8[2] != 'C') {
 		DataFileIO::Read(file, (soundBuffer1_E37A8 + 8), soundBank2[soundIndex2].dword_12 - 8);
-	}
-	else
-	{
+	} else {
 		DataFileIO::Read(file, (soundBuffer1_E37A8 + 8), soundBuffer1_E37A8[7] + ((soundBuffer1_E37A8[6] + ((soundBuffer1_E37A8[5] + (soundBuffer1_E37A8[4] << 8)) << 8)) << 8) - 8);
 		DataFileIO::Decompress(soundBuffer1_E37A8, soundBuffer1_E37A8);
 	}
 	DataFileIO::Seek(file, soundBank2[soundIndex2].dword_0, 0);
 	DataFileIO::Read(file, (uint8_t*)shadow_str_E37A0_sound_buffer2, 8);
-	if (shadow_str_E37A0_sound_buffer2->byte_0 != 'R' || shadow_str_E37A0_sound_buffer2->byte_1 != 'N' || shadow_str_E37A0_sound_buffer2->byte_2 != 'C')//R N C
-	{
+	if (shadow_str_E37A0_sound_buffer2->byte_0 != 'R' || shadow_str_E37A0_sound_buffer2->byte_1 != 'N' || shadow_str_E37A0_sound_buffer2->byte_2 != 'C') {
+		// go back to the start of the bank, since this block has no header
+        DataFileIO::Seek(file, soundBank2[soundIndex2].dword_0, 0);
 		DataFileIO::Read(file, (uint8_t*)&shadow_str_E37A0_sound_buffer2->str_8, soundBank2[soundIndex2].sizeBytes_8 - 8);
 	}
 	else
@@ -1915,17 +1928,10 @@ bool ReadAndDecompressSound(FILE* file, uint8_t soundIndex2)//2654f0
 	soundIndex_E37A0->byte_5 = shadow_str_E37A0_sound_buffer2->byte_5;
 	soundIndex_E37A0->byte_6 = shadow_str_E37A0_sound_buffer2->byte_6;
 	soundIndex_E37A0->byte_7 = shadow_str_E37A0_sound_buffer2->byte_7;
-	for(int i = 0; i < 10; i++)
-		soundIndex_E37A0->str_8.stub[i] = shadow_str_E37A0_sound_buffer2->str_8.stub[i];
 
-	for (int i = 0; i < 96; i++)
+	for (int i = 0; i < numOfLoadedSounds_E37A4; i++)
 	{
 		soundIndex_E37A0->str_8.wavs_10[i].wavData_0 = (uint8_t*)shadow_str_E37A0_sound_buffer2->str_8.wavs_10[i].wavData_0;
-		for (int j = 0; j < 4; j++)
-		{
-			soundIndex_E37A0->str_8.wavs_10[i].stub_4[j] = shadow_str_E37A0_sound_buffer2->str_8.wavs_10[i].stub_4[j];
-		}
-
 		soundIndex_E37A0->str_8.wavs_10[i].wavSize_8 = shadow_str_E37A0_sound_buffer2->str_8.wavs_10[i].wavSize_8;
 		soundIndex_E37A0->str_8.wavs_10[i].word_12 = shadow_str_E37A0_sound_buffer2->str_8.wavs_10[i].word_12;
 		for (int j = 0; j < 18; j++)
@@ -3136,10 +3142,42 @@ void InitSample_A38E0(HSAMPLE S)//2848e0
 		S->sam_var[530] = 0;
 		S->sam_var[531] = 0;
 		S->sam_var532_EOS_ptr = 0;
+		S->id = -1;
 		InitSampleVolume_A2110(S);
 	}
 }
 
+/// \brief prepare the chunk buffer for the openal subsystem 
+/// for chunks that cannot be localized (environment samples) a stereo sample is generated
+/// \param S sample to operate on
+void init_openal_sample(HSAMPLE S)
+{
+    uint8_t actval;
+    uint16_t format;
+
+    format = alsound_get_chunk_flags(S->id);
+
+    if (S->wavbuff != nullptr) {
+        free(S->wavbuff);
+        S->wavbuff = nullptr;
+    }
+
+    if (format & AL_FORMAT_STEREO8_22050) {
+        S->wavbuff = malloc(S->len_4_5[0] * 2);
+        if (!S->wavbuff) {
+            return;
+        }
+
+        for (int i = 0; i < S->len_4_5[0]; i++) {
+            actval = ((uint8_t *) S->start_2_3[0])[i];
+            (*(int8_t *) & ((uint8_t *) S->wavbuff)[0 + i * 2]) = actval;
+            (*(int8_t *) & ((uint8_t *) S->wavbuff)[1 + i * 2]) = actval;
+        }
+    }
+
+    //Logger->info("init_openal_sample id {} fmt {} sz {}", S->id, format, S->len_4_5[0]);
+}
+
 void InitHqsound(HSAMPLE S) {
 	//test mark
 	bool same_mark = true;
@@ -3162,8 +3200,10 @@ void InitHqsound(HSAMPLE S) {
 			S->mark44mark[i] = ((uint8_t*)S->start_2_3[0])[i];
 		}
 
-		if (S->start_44mhz != nullptr)
+		if (S->start_44mhz != nullptr) {
 			free(S->start_44mhz);
+			S->start_44mhz = NULL;
+		}
 		if (fixspeedsound)
 			S->start_44mhz = malloc(S->len_4_5[0] * 2 * 2 * 2 * 2);
 		else
@@ -3208,8 +3248,13 @@ void SetSampleAddress_A3A30(HSAMPLE S, uint8_t* start, uint32_t len)
 		S->start_2_3[1] = 0;
 		S->len_4_5[0] = len;
 		S->len_4_5[1] = 0;
-		if (hqsound)
+#ifdef SOUND_OPENAL
+        init_openal_sample(S);
+#else
+		if (hqsound) {
 			InitHqsound(S);
+		}
+#endif
 	}
 }
 
@@ -5085,7 +5130,7 @@ void sub_8F100_sound_proc19(uint32_t flags, __int16 index, int volume, int volum
 	if (!soundAble_E3798
 		|| !soundActive_E3799
 		|| index > (signed int)indexLoadedSound_180B50
-		|| !_stricmp((const char*)&soundIndex_E37A0->str_8.wavs_10[index -1].filename_14, "null.wav"))
+		|| !_stricmp((const char*)&soundIndex_E37A0->str_8.wavs_10[index].filename_14, "null.wav"))
 	{
 		return;
 	}
@@ -5171,6 +5216,7 @@ void sub_8F100_sound_proc19(uint32_t flags, __int16 index, int volume, int volum
 			for (int i = 0; i < 100; i++)
 				Logger->trace("{}", debug_sound_buff[i]);
 		}
+		(*soundBuffer1)->id = index;
 		AilSetSampleFile_938C0(*soundBuffer1, soundIndex_E37A0->str_8.wavs_10[index].wavData_0, 1);
 	}
 	AilSetSampleVolume_93E30(*soundBuffer1, volume);
@@ -5518,4 +5564,24 @@ void WriteWaveToFile(wav_t* wav, const char* name)
 
 		fclose(wavFile);
 	}
-}
\ No newline at end of file
+}
+
+uint8_t get_sample_ptr(const uint8_t index, uint8_t **data, int32_t *len)
+{
+    *len = 0;
+    *data = NULL;
+    int i;
+    uint8_t *pWaveData = soundIndex_E37A0->str_8.wavs_10[index].wavData_0;
+
+    i = 12;
+    for (int j = _strnicmp((const char *)&pWaveData[12], "data", 4); j; j = _strnicmp((const char *)&pWaveData[i], "data", 4)) {
+        i += (*(int32_t *) & pWaveData[i + 4] & 1) + *(int32_t *) & pWaveData[i + 4] + 8;
+    }
+
+    *data = &pWaveData[i + 8];
+    *len = *(int32_t *) & pWaveData[i + 4];
+
+    //Logger->info("get_sample_ptr  id {}  sz {}", index, *len);
+    return EXIT_SUCCESS;
+}
+
diff --git a/remc2/engine/Sound.h b/remc2/engine/Sound.h
index 33d439477..14669b0b9 100644
--- a/remc2/engine/Sound.h
+++ b/remc2/engine/Sound.h
@@ -257,5 +257,6 @@ void SetSoundFreq_9A230(int a1);
 void WriteWaveToFile(wav_t* wav, const char* name);
 void AIL_fix();
 const char* mygetenv(const char* a1);
+uint8_t get_sample_ptr(const uint8_t index, uint8_t ** data, int32_t * len);
 
-#endif //MAIN_SOUND
\ No newline at end of file
+#endif //MAIN_SOUND
diff --git a/remc2/engine/ail_sound.h b/remc2/engine/ail_sound.h
index dadd4a766..0638919ce 100644
--- a/remc2/engine/ail_sound.h
+++ b/remc2/engine/ail_sound.h
@@ -119,6 +119,8 @@ int32_t sam_var[1000];
    void* start_44mhz;//8
    uint8_t mark44mark[sample_mark];
    //Mix_Chunk chunk;
+	uint8_t id;                 // chunk identifier used in openal functions
+	void *wavbuff;              // stereo wav chunk data used in openal functions
 }
 SAMPLE;
 typedef MSS_STRUCT _SAMPLE * HSAMPLE;           // Handle to sample
diff --git a/remc2/engine/engine_support.h b/remc2/engine/engine_support.h
index 0ecb437b0..2098dcd45 100644
--- a/remc2/engine/engine_support.h
+++ b/remc2/engine/engine_support.h
@@ -22,6 +22,7 @@
 #include "../portability/port_time.h"
 #include "../portability/port_sdl_vga_mouse.h"
 #include "../portability/port_sdl_joystick.h"
+#include "../portability/port_openal.h"
 #include "../portability/port_outputs.h"
 #include "../portability/port_show_perifery.h"
 
diff --git a/remc2/engine/global_types.h b/remc2/engine/global_types.h
index 4403c682b..b86eaba51 100644
--- a/remc2/engine/global_types.h
+++ b/remc2/engine/global_types.h
@@ -362,6 +362,10 @@ typedef struct _str_0x6E8E {//lenght a8//THING
 	type_str_160* dword_0xA0_160x;//160 //special settings
 	//uint16_t word_0xA2_162;//162
 	type_str_164* dword_0xA4_164x;//100 // adress of xx
+	int16_t play_ch;                    ///< play channel currently used to play this entity's sound sample
+	uint64_t play_mark;                 ///< when this entity is supposed to play it's sound sample (in ms)
+	uint32_t dist;                      ///< distance between this entity and the listener
+	uint64_t dist_mark;                 ///< when should the distance be recalculated (in ms)
 }
 type_event_0x6E8E;
 
diff --git a/remc2/engine/read_config.cpp b/remc2/engine/read_config.cpp
index 74f8171f8..7712d7d1e 100644
--- a/remc2/engine/read_config.cpp
+++ b/remc2/engine/read_config.cpp
@@ -1,4 +1,5 @@
 #include "read_config.h"
+#include "../sub_main.h"
 
 int config_skip_screen;
 int texturepixels = 32;
@@ -144,6 +145,18 @@ bool readini() {
 	std::string readstr = reader.GetString("sound", "oggmusicFolder", "");
 	strcpy(oggmusicFolder, (char*)readstr.c_str());
 
+    std::string speech_folder_str = reader.GetString("sound", "speech_folder", "");
+    strcpy(speech_folder, (char *)speech_folder_str.c_str());
+    oac.speech_volume = reader.GetInteger("sound", "openal_speech_volume", 102);
+
+    if ((oac.speech_volume == 0) || (speech_folder_str.length() < 3)) {
+        disable_speech();
+    }
+
+    oac.env_volume = reader.GetInteger("sound", "openal_environment_volume", 52);
+    oac.efx_enabled = reader.GetBoolean("sound", "openal_efx", false);
+    oac.same_chunk_concurrency = reader.GetInteger("sound", "openal_same_chunk_concurrency", 5);
+
 	std::string readstr3 = reader.GetString("graphics", "bigGraphicsFolder", "");
 	strcpy(bigGraphicsFolder, (char*)readstr3.c_str());
 
@@ -217,100 +230,101 @@ bool readini() {
 	fmvFps = reader.GetInteger("game", "fmvFps", 20);
 	loggingLevel = reader.GetString("game", "loggingLevel", "Info");
 
-	gpc.axis_yaw = reader.GetInteger("gamepad", "axis_yaw", GAMEPAD_ITEM_DISABLED);
-	gpc.axis_pitch = reader.GetInteger("gamepad", "axis_pitch", GAMEPAD_ITEM_DISABLED);
-	gpc.axis_long = reader.GetInteger("gamepad", "axis_long", GAMEPAD_ITEM_DISABLED);
-	gpc.axis_trans = reader.GetInteger("gamepad", "axis_trans", GAMEPAD_ITEM_DISABLED);
-	gpc.axis_nav_ns = reader.GetInteger("gamepad", "axis_nav_ns", GAMEPAD_ITEM_DISABLED);
-	gpc.axis_nav_ew = reader.GetInteger("gamepad", "axis_nav_ew", GAMEPAD_ITEM_DISABLED);
-	gpc.axis_fire_R = reader.GetInteger("gamepad", "axis_fire_R", GAMEPAD_ITEM_DISABLED);
-	gpc.axis_fire_L = reader.GetInteger("gamepad", "axis_fire_L", GAMEPAD_ITEM_DISABLED);
-
-	gp_temp = reader.GetBoolean("gamepad", "axis_yaw_inv", 0);
-	if (gpc.axis_yaw) {
-		gpc.axis_yaw -= 1; // go back to SDL axis notation
-		gpc.axis_yaw_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	gp_temp = reader.GetBoolean("gamepad", "axis_pitch_inv", 0);
-	if (gpc.axis_pitch) {
-		gpc.axis_pitch -= 1; // go back to SDL axis notation
-		gpc.axis_pitch_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	gp_temp = reader.GetBoolean("gamepad", "axis_long_inv", 0);
-	if (gpc.axis_long) {
-		gpc.axis_long -= 1; // go back to SDL axis notation
-		gpc.axis_long_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	gp_temp = reader.GetBoolean("gamepad", "axis_trans_inv", 0);
-	if (gpc.axis_trans) {
-		gpc.axis_trans -= 1; // go back to SDL axis notation
-		gpc.axis_trans_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	gp_temp = reader.GetBoolean("gamepad", "axis_nav_ns_inv", 0);
-	if (gpc.axis_nav_ns) {
-		gpc.axis_nav_ns -= 1; // go back to SDL axis notation
-		gpc.axis_nav_ns_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	gp_temp = reader.GetBoolean("gamepad", "axis_nav_ew_inv", 0);
-	if (gpc.axis_nav_ew) {
-		gpc.axis_nav_ew -= 1; // go back to SDL axis notation
-		gpc.axis_nav_ew_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	if (gpc.axis_fire_R) {
-		gpc.axis_fire_R -= 1; // go back to SDL axis notation
-		gpc.axis_fire_R_conf = GAMEPAD_ITEM_ENABLED;
-	}
-
-	if (gpc.axis_fire_L) {
-		gpc.axis_fire_L -= 1; // go back to SDL axis notation
-		gpc.axis_fire_L_conf = GAMEPAD_ITEM_ENABLED;
-	}
-
-	gpc.button_fire_L = reader.GetInteger("gamepad", "button_fire_L", 0);
-	gpc.button_fire_R = reader.GetInteger("gamepad", "button_fire_R", 0);
-	gpc.controller_id = reader.GetInteger("gamepad", "controller_id", 0);
-	gpc.button_spell = reader.GetInteger("gamepad", "button_spell", 0);
-	gpc.button_minimap = reader.GetInteger("gamepad", "button_minimap", 0);
-	gpc.button_fwd = reader.GetInteger("gamepad", "button_fwd", 0);
-	gpc.button_back = reader.GetInteger("gamepad", "button_back", 0);
-	gpc.button_pause_menu = reader.GetInteger("gamepad", "button_pause_menu", 0);
-	gpc.button_esc = reader.GetInteger("gamepad", "button_esc", 0);
-	gpc.button_menu_select = reader.GetInteger("gamepad", "button_menu_select", 0);
-
-	gpc.axis_yaw_sensitivity = ReadZones(reader.GetString("gamepad", "axis_yaw_sensitivity", ""));
-	gpc.axis_yaw_dead_zone = reader.GetInteger("gamepad", "axis_yaw_dead_zone", 3000);
-	gpc.axis_pitch_sensitivity = ReadZones(reader.GetString("gamepad", "axis_pitch_sensitivity", ""));
-	gpc.axis_pitch_dead_zone = reader.GetInteger("gamepad", "axis_pitch_dead_zone", 3000);
-	gpc.axis_long_dead_zone = reader.GetInteger("gamepad", "axis_long_dead_zone", 3000);
-	gpc.axis_trans_dead_zone = reader.GetInteger("gamepad", "axis_trans_dead_zone", 3000);
-	gpc.axis_long_nav_dead_zone = reader.GetInteger("gamepad", "axis_long_nav_dead_zone", 6000);
-	gpc.axis_trans_nav_dead_zone = reader.GetInteger("gamepad", "axis_trans_nav_dead_zone", 6000);
-
-	gpc.trigger_dead_zone = reader.GetInteger("gamepad", "trigger_dead_zone", 3000);
-
-	gpc.hat_nav = reader.GetInteger("gamepad", "hat_nav", GAMEPAD_ITEM_DISABLED);
-	gpc.hat_mov = reader.GetInteger("gamepad", "hat_mov", GAMEPAD_ITEM_DISABLED);
-
-	gp_temp = reader.GetBoolean("gamepad", "hat_nav_inv", 0);
-	if (gpc.hat_nav) {
-		gpc.hat_nav -= 1; // go back to SDL axis notation
-		gpc.hat_nav_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	gp_temp = reader.GetBoolean("gamepad", "hat_mov_inv", 0);
-	if (gpc.hat_mov) {
-		gpc.hat_mov -= 1; // go back to SDL axis notation
-		gpc.hat_mov_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
-	}
-
-	gpc.haptic_enabled = reader.GetBoolean("gamepad", "haptic_enabled", false);
-	gpc.haptic_gain_max = reader.GetInteger("gamepad", "haptic_max_gain", 75);
 
-	return true;
+    gpc.axis_yaw = reader.GetInteger("gamepad", "axis_yaw", GAMEPAD_ITEM_DISABLED);
+    gpc.axis_pitch = reader.GetInteger("gamepad", "axis_pitch", GAMEPAD_ITEM_DISABLED);
+    gpc.axis_long = reader.GetInteger("gamepad", "axis_long", GAMEPAD_ITEM_DISABLED);
+    gpc.axis_trans = reader.GetInteger("gamepad", "axis_trans", GAMEPAD_ITEM_DISABLED);
+    gpc.axis_nav_ns = reader.GetInteger("gamepad", "axis_nav_ns", GAMEPAD_ITEM_DISABLED);
+    gpc.axis_nav_ew = reader.GetInteger("gamepad", "axis_nav_ew", GAMEPAD_ITEM_DISABLED);
+    gpc.axis_fire_R = reader.GetInteger("gamepad", "axis_fire_R", GAMEPAD_ITEM_DISABLED);
+    gpc.axis_fire_L = reader.GetInteger("gamepad", "axis_fire_L", GAMEPAD_ITEM_DISABLED);
+
+    gp_temp = reader.GetBoolean("gamepad", "axis_yaw_inv", 0);
+    if (gpc.axis_yaw) {
+        gpc.axis_yaw -= 1;      // go back to SDL axis notation
+        gpc.axis_yaw_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    gp_temp = reader.GetBoolean("gamepad", "axis_pitch_inv", 0);
+    if (gpc.axis_pitch) {
+        gpc.axis_pitch -= 1;    // go back to SDL axis notation
+        gpc.axis_pitch_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    gp_temp = reader.GetBoolean("gamepad", "axis_long_inv", 0);
+    if (gpc.axis_long) {
+        gpc.axis_long -= 1;     // go back to SDL axis notation
+        gpc.axis_long_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    gp_temp = reader.GetBoolean("gamepad", "axis_trans_inv", 0);
+    if (gpc.axis_trans) {
+        gpc.axis_trans -= 1;    // go back to SDL axis notation
+        gpc.axis_trans_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    gp_temp = reader.GetBoolean("gamepad", "axis_nav_ns_inv", 0);
+    if (gpc.axis_nav_ns) {
+        gpc.axis_nav_ns -= 1;   // go back to SDL axis notation
+        gpc.axis_nav_ns_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    gp_temp = reader.GetBoolean("gamepad", "axis_nav_ew_inv", 0);
+    if (gpc.axis_nav_ew) {
+        gpc.axis_nav_ew -= 1;   // go back to SDL axis notation
+        gpc.axis_nav_ew_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    if (gpc.axis_fire_R) {
+        gpc.axis_fire_R -= 1;   // go back to SDL axis notation
+        gpc.axis_fire_R_conf = GAMEPAD_ITEM_ENABLED;
+    }
+
+    if (gpc.axis_fire_L) {
+        gpc.axis_fire_L -= 1;   // go back to SDL axis notation
+        gpc.axis_fire_L_conf = GAMEPAD_ITEM_ENABLED;
+    }
+
+    gpc.controller_id = reader.GetInteger("gamepad", "controller_id", 0);
+    gpc.button_fire_L = reader.GetInteger("gamepad", "button_fire_L", 0);
+    gpc.button_fire_R = reader.GetInteger("gamepad", "button_fire_R", 0);
+    gpc.button_spell = reader.GetInteger("gamepad", "button_spell", 0);
+    gpc.button_minimap = reader.GetInteger("gamepad", "button_minimap", 0);
+    gpc.button_fwd = reader.GetInteger("gamepad", "button_fwd", 0);
+    gpc.button_back = reader.GetInteger("gamepad", "button_back", 0);
+    gpc.button_pause_menu = reader.GetInteger("gamepad", "button_pause_menu", 0);
+    gpc.button_esc = reader.GetInteger("gamepad", "button_esc", 0);
+    gpc.button_menu_select = reader.GetInteger("gamepad", "button_menu_select", 0);
+    gpc.inflection_x = reader.GetInteger("gamepad", "inflection_x", 0);
+    gpc.inflection_y = reader.GetInteger("gamepad", "inflection_y", 0);
+
+    gpc.axis_yaw_dead_zone = reader.GetInteger("gamepad", "axis_yaw_dead_zone", 3000);
+    gpc.axis_pitch_dead_zone = reader.GetInteger("gamepad", "axis_pitch_dead_zone", 3000);
+    gpc.axis_long_nav_dead_zone = reader.GetInteger("gamepad", "axis_long_nav_dead_zone", 6000);
+    gpc.axis_trans_nav_dead_zone = reader.GetInteger("gamepad", "axis_trans_nav_dead_zone", 6000);
+    gpc.axis_long_dead_zone = reader.GetInteger("gamepad", "axis_long_dead_zone", 12000);
+    gpc.axis_trans_dead_zone = reader.GetInteger("gamepad", "axis_trans_dead_zone", 12000);
+
+    gpc.trigger_dead_zone = reader.GetInteger("gamepad", "trigger_dead_zone", 3000);
+
+    gpc.hat_nav = reader.GetInteger("gamepad", "hat_nav", GAMEPAD_ITEM_DISABLED);
+    gpc.hat_mov = reader.GetInteger("gamepad", "hat_mov", GAMEPAD_ITEM_DISABLED);
+
+    gp_temp = reader.GetBoolean("gamepad", "hat_nav_inv", 0);
+    if (gpc.hat_nav) {
+        gpc.hat_nav -= 1;       // go back to SDL axis notation
+        gpc.hat_nav_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    gp_temp = reader.GetBoolean("gamepad", "hat_mov_inv", 0);
+    if (gpc.hat_mov) {
+        gpc.hat_mov -= 1;       // go back to SDL axis notation
+        gpc.hat_mov_conf = GAMEPAD_ITEM_ENABLED | (gp_temp ? GAMEPAD_AXIS_INVERTED : 0);
+    }
+
+    gpc.haptic_enabled = reader.GetBoolean("gamepad", "haptic_enabled", false);
+    gpc.haptic_gain_max = reader.GetInteger("gamepad", "haptic_max_gain", 75);
+
+    return true;
 };
diff --git a/remc2/engine/read_config.h b/remc2/engine/read_config.h
index 04683436d..475b49688 100644
--- a/remc2/engine/read_config.h
+++ b/remc2/engine/read_config.h
@@ -61,50 +61,59 @@ extern bool assignToSpecificCores;
 #define   GAMEPAD_AXIS_INVERTED  0x2
 
 struct gamepad_config {
-	uint16_t axis_yaw;
-	uint16_t axis_pitch;
-	uint16_t axis_long;
-	uint16_t axis_trans;
-	uint16_t axis_nav_ns;
-	uint16_t axis_nav_ew;
-	uint16_t axis_fire_R;
-	uint16_t axis_fire_L;
-	uint8_t axis_yaw_conf;
-	uint8_t axis_pitch_conf;
-	uint8_t axis_long_conf;
-	uint8_t axis_trans_conf;
-	uint8_t axis_nav_ns_conf;
-	uint8_t axis_nav_ew_conf;
-	uint8_t axis_fire_R_conf;
-	uint8_t axis_fire_L_conf;
-	std::vector<Maths::Zone> axis_yaw_sensitivity;
-	uint16_t axis_yaw_dead_zone;
-	std::vector<Maths::Zone> axis_pitch_sensitivity;
-	uint16_t axis_pitch_dead_zone;
-	uint16_t axis_long_dead_zone;
-	uint16_t axis_trans_dead_zone;
-	uint16_t axis_long_nav_dead_zone;
-	uint16_t axis_trans_nav_dead_zone;
-	uint16_t trigger_dead_zone;
-	uint16_t hat_nav;
-	uint16_t hat_mov;
-	uint8_t hat_mov_conf;
-	uint8_t hat_nav_conf;
-	uint16_t controller_id;
-	uint16_t button_spell;
-	uint16_t button_minimap;
-	uint16_t button_fire_L;
-	uint16_t button_fire_R;
-	uint16_t button_fwd;
-	uint16_t button_back;
-	uint16_t button_pause_menu;
-	uint16_t button_esc;
-	uint16_t button_menu_select;
-	bool haptic_enabled;
-	uint16_t haptic_gain_max;
+    uint16_t controller_id;
+    uint16_t axis_yaw;
+    uint16_t axis_pitch;
+    uint16_t axis_long;
+    uint16_t axis_trans;
+    uint16_t axis_nav_ns;
+    uint16_t axis_nav_ew;
+    uint16_t axis_fire_R;
+    uint16_t axis_fire_L;
+    uint8_t axis_yaw_conf;
+    uint8_t axis_pitch_conf;
+    uint8_t axis_long_conf;
+    uint8_t axis_trans_conf;
+    uint8_t axis_nav_ns_conf;
+    uint8_t axis_nav_ew_conf;
+    uint8_t axis_fire_R_conf;
+    uint8_t axis_fire_L_conf;
+    uint16_t axis_yaw_dead_zone;
+    uint16_t axis_pitch_dead_zone;
+    uint16_t axis_long_dead_zone;
+    uint16_t axis_trans_dead_zone;
+    uint16_t axis_long_nav_dead_zone;
+    uint16_t axis_trans_nav_dead_zone;
+    uint16_t trigger_dead_zone;
+    uint16_t hat_nav;
+    uint16_t hat_mov;
+    uint8_t hat_mov_conf;
+    uint8_t hat_nav_conf;
+    uint16_t button_spell;
+    uint16_t button_minimap;
+    uint16_t button_fire_L;
+    uint16_t button_fire_R;
+    uint16_t button_fwd;
+    uint16_t button_back;
+    uint16_t button_pause_menu;
+    uint16_t button_esc;
+    uint16_t button_menu_select;
+    bool haptic_enabled;
+    uint16_t haptic_gain_max;
+    uint8_t inflection_x; ///< middle-band wideness (percentage 70-99)
+    uint8_t inflection_y; ///< f(x) at the edges of the middle-band (percentage 10-90)
 };
 
 typedef struct gamepad_config gamepad_config_t;
 extern gamepad_config_t gpc;
 
-#endif //READ_CONFIG
+struct openal_config {
+    bool efx_enabled;
+    uint16_t speech_volume;
+    uint16_t env_volume;
+    uint16_t same_chunk_concurrency;
+};
+typedef struct openal_config openal_config_t;
+extern openal_config_t oac;
+
+#endif                          //READ_CONFIG
diff --git a/remc2/portability/port_openal.cpp b/remc2/portability/port_openal.cpp
new file mode 100644
index 000000000..dd43c27df
--- /dev/null
+++ b/remc2/portability/port_openal.cpp
@@ -0,0 +1,964 @@
+
+// OpenAL 3D audio implementation
+//
+// includes reverb effect for added ambiance and the makings of a few positional elements
+//
+// resources:
+// OpenAL official doc https://www.openal.org/documentation/
+// OpenAL-soft doc     https://github.com/kcat/openal-soft/wiki/Programmer%27s-Guide
+// nice guide          https://indiegamedev.net/2020/04/12/the-complete-guide-to-openal-with-c-part-3-positioning-sounds/
+// EFX code based on   https://github.com/kcat/openal-soft/blob/master/examples/alreverb.c
+//
+// Authors:
+//    2023 - Petre Rodan (complete rewrite)
+//
+
+#include <stdlib.h>
+#include "AL/al.h"
+#include "AL/alc.h"
+#include "AL/alext.h"
+#include "AL/efx.h"
+#include "AL/efx-presets.h"
+#include "../engine/ail_sound.h"
+#include "../engine/global_types.h"
+#include "../engine/read_config.h"
+#include "../engine/Sound.h"
+#include "port_sound_lut.h"
+#include "port_sdl_sound.h"
+#include "port_openal.h"
+
+///< al_chunk_cache_t flags
+#define          OPENAL_FLG_LOADED  0x1     ///< if chunk was properly loaded via alBufferData()
+
+#define   AL_DIST_REFRESH_INTERVAL  200     ///< after how many ms shoud the distance between creatures and the listener should be refreshed
+#define           AL_DIST_MIN_PLAY  10000   ///< minimal distance to the player needed for creature to play it's sample
+
+// Effect object functions
+static LPALGENEFFECTS alGenEffects;
+static LPALDELETEEFFECTS alDeleteEffects;
+static LPALISEFFECT alIsEffect;
+static LPALEFFECTI alEffecti;
+static LPALEFFECTIV alEffectiv;
+static LPALEFFECTF alEffectf;
+static LPALEFFECTFV alEffectfv;
+static LPALGETEFFECTI alGetEffecti;
+static LPALGETEFFECTIV alGetEffectiv;
+static LPALGETEFFECTF alGetEffectf;
+static LPALGETEFFECTFV alGetEffectfv;
+
+// Auxiliary Effect Slot object functions
+static LPALGENAUXILIARYEFFECTSLOTS alGenAuxiliaryEffectSlots;
+static LPALDELETEAUXILIARYEFFECTSLOTS alDeleteAuxiliaryEffectSlots;
+static LPALISAUXILIARYEFFECTSLOT alIsAuxiliaryEffectSlot;
+static LPALAUXILIARYEFFECTSLOTI alAuxiliaryEffectSloti;
+static LPALAUXILIARYEFFECTSLOTIV alAuxiliaryEffectSlotiv;
+static LPALAUXILIARYEFFECTSLOTF alAuxiliaryEffectSlotf;
+static LPALAUXILIARYEFFECTSLOTFV alAuxiliaryEffectSlotfv;
+static LPALGETAUXILIARYEFFECTSLOTI alGetAuxiliaryEffectSloti;
+static LPALGETAUXILIARYEFFECTSLOTIV alGetAuxiliaryEffectSlotiv;
+static LPALGETAUXILIARYEFFECTSLOTF alGetAuxiliaryEffectSlotf;
+static LPALGETAUXILIARYEFFECTSLOTFV alGetAuxiliaryEffectSlotfv;
+
+struct al_chunk {
+    int16_t id;                 ///< chunk identifier
+    ALint state;                ///< 0, AL_PLAYING or something in between
+    ALuint alSource;            ///< openal source identifier
+    ALsizei size;               ///< chunk size
+    event_t *entity;            ///< what entity has created the sound source
+};
+typedef struct al_chunk al_chunk_t;     ///< element of the currently playing chunks array
+
+struct al_chunk_cache {
+    int16_t id;                 ///< chunk identifier
+    uint16_t flags;             ///< 0 or OPENAL_FLG_LOADED
+    ALuint bufferName;          ///< openal buffer identifier
+    ALsizei size;               ///< chunk size
+};
+typedef struct al_chunk_cache al_chunk_cache_t; ///< element of the cached chunks array
+
+struct al_env {
+    uint8_t initialized;        ///< '1' if the OpenAL-soft library was properly initialized
+    uint8_t efx_initialized;    ///< '1' if the ALC_EXT_EFX extension is usable
+    uint8_t scheduling_enabled; ///< state of the chunk scheduling
+    int8_t bank;                ///< current sound bank
+    int8_t reverb_type;         ///< should match the current MapType
+    uint32_t frame_cnt;         ///< frame counter
+    axis_3d listener_c;         ///< the listener's coordinates in game space (x, y, z)
+    axis_4d listener_o;         ///< the listener's orientation values (yaw, pitch, roll)
+};
+typedef struct al_env al_env_t; ///< random collection of global variables
+
+struct al_next_vol {            ///< sometimes the volume of a chunk is received before the chunk itself, so keep that info here
+    int16_t chunk_id;           ///< chunk identifier
+    float gain;                 ///< volume (0-127) converted into gain (0-1.0)
+};
+typedef struct al_next_vol al_next_vol_t;
+
+ALCcontext *context;
+ALuint al_slot;                 ///< effect slot
+ALuint al_effect;
+al_chunk_t alc[OPENAL_C_SZ] = { };      ///< currently playing chunks array
+al_chunk_cache_t alcc[OPENAL_CC_SZ] = { };      ///< cached chunks array
+int8_t al_con[OPENAL_CC_SZ] = { }; ///< concurrency array (how many times is a particular chunk played currently)
+al_env_t ale = { };             ///< the random collection of global variables
+
+openal_config_t oac;            ///< subsystem configuration read from config.ini
+
+// alsound_set_sample_volume for a chunk precedes alsound_play
+// for that particular chunk. so store it's volume in alnv:
+al_next_vol_t alnv = { };
+
+const char *alsound_get_error_str(ALCenum error);
+ALCenum alsound_error_check(const char *msg);
+static ALuint alsound_load_effect(const EFXEAXREVERBPROPERTIES * reverb);
+
+/// \brief find a chunk_id in the currently playing chunks array
+/// \param chunk_id  identifier
+/// \return location in the array or -1 if chunk not present
+int16_t alsound_find_alc_sample(const int32_t id)
+{
+    int16_t i;
+    //Logger->info("alsound_sample_status looking for {}", chunk_id);
+    if (id > 128) {
+        for (i = OPENAL_C_SZ; i > 0; i--) {
+            if ((alc[i - 1].state == AL_PLAYING) && (alc[i - 1].size == id)) {
+                return i - 1;
+            }
+        }
+    } else {
+        for (i = OPENAL_C_SZ; i > 0; i--) {
+            if ((alc[i - 1].state == AL_PLAYING) && (alc[i - 1].id == id)) {
+                return i - 1;
+            }
+        }
+    }
+    return -1;
+}
+
+/// \brief establish the presence of a chunk_id in the currently playing chunks array
+/// \param chunk_id  identifier
+/// \return  1 if sample is playing and 0 otherwise
+uint8_t alsound_sample_status(const int32_t id)
+{
+    if (alsound_find_alc_sample(id) > -1) {
+        return 1;
+    }
+    return 0;
+}
+
+/// \brief delete source based on play channel id
+/// \param channel_id alc[] array index
+void alsound_delete_source(const int16_t channel_id)
+{
+    //Logger->info("alsound_delete_source {}", channel_id);
+    alDeleteSources(1, &alc[channel_id].alSource);
+    alsound_error_check("alsound_delete_source alDeleteSources");
+    if (alc[channel_id].entity) {
+        //Logger->info("delete_source {}", channel_id);
+        alc[channel_id].entity->play_ch = -1;
+        alc[channel_id].entity = 0;
+    }
+    al_con[alc[channel_id].id]--;
+    alc[channel_id].state = 0;
+    alc[channel_id].size = 0;
+    alc[channel_id].id = -1;
+}
+
+/// \brief stop chunk from playing based on chunk id
+/// \param chunk_id  identifier
+void alsound_end_sample(const int32_t chunk_id)
+{
+    int16_t ret;
+    ret = alsound_find_alc_sample(chunk_id);
+    if (ret > -1) {
+        //Logger->info("alsound_end_sample id {}  ch {}", chunk_id, ret);
+        alsound_delete_source(ret);
+    }
+}
+
+/// \brief change the volume of a chunk that is currently playing
+/// \param chunk_id  identifier
+/// \param volume    0-127
+void alsound_set_sample_volume(const int32_t chunk_id, const int32_t volume)
+{
+    int16_t ret;
+    float gain = (float)volume / 127.0f;
+
+    if (ale.bank < 3) {
+        if (alct[ale.bank][chunk_id].flags & AL_IGNORE_RECODE) {
+            return;
+        }
+    }
+
+    ret = alsound_find_alc_sample(chunk_id);
+    if (ret > -1) {
+        alSourcef(alc[ret].alSource, AL_GAIN, gain);
+        alsound_error_check("set_sample_volume alSourcef");
+        //Logger->info("alsound_set_sample_volume {} {}", chunk_id, gain);
+    }
+
+    alnv.chunk_id = chunk_id;
+    alnv.gain = gain;
+}
+
+/// \brief initialize OpenAL and it's EFX subsystem
+void alsound_init()
+{
+    ALboolean enumeration;
+    const ALCchar *defaultDeviceName;
+    ALCdevice *device;
+    EFXEAXREVERBPROPERTIES reverb = EFX_REVERB_PRESET_GENERIC;
+
+    enumeration = alcIsExtensionPresent(NULL, "ALC_ENUMERATION_EXT");
+    if (enumeration == AL_FALSE) {
+        Logger->error("OpenAL: enumeration extension not available");
+    }
+
+    defaultDeviceName = alcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
+
+    device = alcOpenDevice(defaultDeviceName);
+    if (!device) {
+        Logger->error("OpenAL: unable to open device");
+        return;
+    }
+
+    Logger->info("OpenAL device: {}", alcGetString(device, ALC_DEVICE_SPECIFIER));
+    alGetError();
+
+    context = alcCreateContext(device, NULL);
+    if (!alcMakeContextCurrent(context)) {
+        Logger->error("OpenAL: unable to create default context");
+        return;
+    }
+
+    if (alIsExtensionPresent("EAX-RAM") == AL_TRUE) {
+        Logger->info("EAX-RAM was found!");
+    }
+
+    //alDistanceModel(AL_NONE);
+    alDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
+    alsound_error_check("alDistanceModel");
+    ale.frame_cnt = 0;
+    ale.initialized = 1;
+
+    if (oac.efx_enabled) {
+        if (!alcIsExtensionPresent(device, "ALC_EXT_EFX")) {
+            Logger->error("OpenAL: EFX not supported");
+        } else {
+            alGenEffects = (LPALGENEFFECTS) alGetProcAddress("alGenEffects");
+            alDeleteEffects = (LPALDELETEEFFECTS) alGetProcAddress("alDeleteEffects");
+            alIsEffect = (LPALISEFFECT) alGetProcAddress("alIsEffect");
+            alEffecti = (LPALEFFECTI) alGetProcAddress("alEffecti");
+            alEffectiv = (LPALEFFECTIV) alGetProcAddress("alEffectiv");
+            alEffectf = (LPALEFFECTF) alGetProcAddress("alEffectf");
+            alEffectfv = (LPALEFFECTFV) alGetProcAddress("alEffectfv");
+            alGetEffecti = (LPALGETEFFECTI) alGetProcAddress("alGetEffecti");
+            alGetEffectiv = (LPALGETEFFECTIV) alGetProcAddress("alGetEffectiv");
+            alGetEffectf = (LPALGETEFFECTF) alGetProcAddress("alGetEffectf");
+            alGetEffectfv = (LPALGETEFFECTFV) alGetProcAddress("alGetEffectfv");
+
+            alGenAuxiliaryEffectSlots = (LPALGENAUXILIARYEFFECTSLOTS) alGetProcAddress("alGenAuxiliaryEffectSlots");
+            alDeleteAuxiliaryEffectSlots = (LPALDELETEAUXILIARYEFFECTSLOTS) alGetProcAddress("alDeleteAuxiliaryEffectSlots");
+            alIsAuxiliaryEffectSlot = (LPALISAUXILIARYEFFECTSLOT) alGetProcAddress("alIsAuxiliaryEffectSlot");
+            alAuxiliaryEffectSloti = (LPALAUXILIARYEFFECTSLOTI) alGetProcAddress("alAuxiliaryEffectSloti");
+            alAuxiliaryEffectSlotiv = (LPALAUXILIARYEFFECTSLOTIV) alGetProcAddress("alAuxiliaryEffectSlotiv");
+            alAuxiliaryEffectSlotf = (LPALAUXILIARYEFFECTSLOTF) alGetProcAddress("alAuxiliaryEffectSlotf");
+            alAuxiliaryEffectSlotfv = (LPALAUXILIARYEFFECTSLOTFV) alGetProcAddress("alAuxiliaryEffectSlotfv");
+            alGetAuxiliaryEffectSloti = (LPALGETAUXILIARYEFFECTSLOTI) alGetProcAddress("alGetAuxiliaryEffectSloti");
+            alGetAuxiliaryEffectSlotiv = (LPALGETAUXILIARYEFFECTSLOTIV) alGetProcAddress("alGetAuxiliaryEffectSlotiv");
+            alGetAuxiliaryEffectSlotf = (LPALGETAUXILIARYEFFECTSLOTF) alGetProcAddress("alGetAuxiliaryEffectSlotf");
+            alGetAuxiliaryEffectSlotfv = (LPALGETAUXILIARYEFFECTSLOTFV) alGetProcAddress("alGetAuxiliaryEffectSlotfv");
+
+            al_effect = alsound_load_effect(&reverb);
+            if (!al_effect) {
+                Logger->error("OpenAL: cannot load effect");
+            } else {
+                al_slot = 0;
+                alGenAuxiliaryEffectSlots(1, &al_slot);
+                alAuxiliaryEffectSloti(al_slot, AL_EFFECTSLOT_EFFECT, (ALint) al_effect);
+                if (alGetError() == AL_NO_ERROR) {
+                    Logger->info("OpenAL: EFX init success");
+                    ale.efx_initialized = 1;
+                }
+            }
+        }
+    }
+
+    srand((unsigned int)time(NULL));
+}
+
+/// \brief set environmental variables
+/// \param value  multiple-role input
+/// \param flag   role-defining option: AL_SET_BANK 
+void alsound_set_env(const int32_t value, const uint8_t flag)
+{
+    switch (flag) {
+    case AL_SET_BANK:
+        ale.bank = value;
+        break;
+    default:
+        break;
+    }
+}
+
+/// \brief update the listener's position once every frame
+/// \param coord  cartesian coordinates
+/// \param orient orientation
+void alsound_set_location(axis_3d *coord, axis_4d *orient)
+{
+    ale.listener_c.x = coord->x;
+    ale.listener_c.y = coord->y;
+    ale.listener_c.z = coord->z;
+
+    ale.listener_o.yaw = orient->yaw;
+    //ale.listener_r.pitch = orient->pitch;
+    //ale.listener_r.roll = orient->roll;
+    //Logger->info("set location {} {} {}", ale.listener_c.x, ale.listener_c.y, ale.listener_c.z);
+}
+
+/// \brief cleanup currently playing chunk array, apply listener position called once every frame
+void alsound_update(void)
+{
+    int16_t i;
+    ALCenum ret;
+    float angle;
+    int16_t yaw_corrected;
+    event_t *entity;
+    uint8_t idx = 0;
+
+    if (!ale.initialized) {
+        return;
+    }
+
+    ale.frame_cnt++;
+    alGetError();               // reset global error variable
+
+    for (i = OPENAL_C_SZ; i > 0; i--) {
+        if (alc[i - 1].state == AL_PLAYING) {
+            alGetSourcei(alc[i - 1].alSource, AL_SOURCE_STATE, &alc[i - 1].state);
+            ret = alGetError();
+            if (ret != AL_NO_ERROR) {
+                Logger->error("error during alGetSourcei: {} for i {}", alsound_get_error_str(ret), i - 1);
+            }
+        } else if (alc[i - 1].state != 0) {
+            alsound_delete_source(i - 1);
+        }
+    }
+
+    // update the position and orientation of the listener
+    // based on it's movement in game space
+    alListener3f(AL_POSITION, ale.listener_c.x, ale.listener_c.y, ale.listener_c.z);
+    alsound_error_check("alListener3f AL_POSITION");
+
+    // the yaw needs to be corrected by 90 degrees in the xy plane
+    yaw_corrected = ale.listener_o.yaw + 512;
+    if (yaw_corrected > 2048) {
+        yaw_corrected -= 2048;
+    }
+
+    angle = 2.0f * M_PI * yaw_corrected / 2048.0f;
+    ALfloat orientation[] = { cos(angle), sin(angle), 0.0f, 0.0f, 0.0f, 1.0f };
+    alListenerfv(AL_ORIENTATION, orientation);
+    alsound_error_check("alListenerfv AL_ORIENTATION");
+
+    // ignoring velocity for now
+    alListener3f(AL_VELOCITY, 0, 0, 0);
+    alsound_error_check("alListener3f AL_VELOCITY");
+
+    // get all creature positions
+    idx = 0;
+    do {
+        for (entity = x_D41A0_BYTEARRAY_4_struct.bytearray_38403x[idx]; entity > x_DWORD_EA3E4[0]; entity = entity->next_0) {
+            if ((entity->class_0x3F_63 == 5) && (alcrt[entity->model_0x40_64].chunk_id != -1) && (ale.scheduling_enabled)) {
+                alsound_update_source(entity);
+            }
+        }
+        idx++;
+    } while (idx < 29);
+}
+
+/// \brief cache chunk into the chunk cache array
+/// \param cache_ch  empty index to be used
+/// \param chunk_id  identifier
+/// \param mixchunk  SDL2_mixer compatible struct holding chunk data
+void alsound_cache(const int16_t cache_ch, const int16_t chunk_id, const Mix_Chunk *mixchunk, const uint16_t flags)
+{
+    ALCenum ret;
+
+    // save chunk to disk for debug
+    //alsound_save_chunk(mixchunk->abuf, mixchunk->alen, NULL);
+
+    alGetError();               // reset global error variable
+    alGenBuffers(1, &alcc[cache_ch].bufferName);
+    alsound_error_check("alGenBuffers");
+    if (flags & AL_FORMAT_STEREO8_22050) {
+        alBufferData(alcc[cache_ch].bufferName, AL_FORMAT_STEREO8, mixchunk->abuf, mixchunk->alen, 22050);
+    } else if (flags & AL_FORMAT_STEREO16_44100) {
+        alBufferData(alcc[cache_ch].bufferName, AL_FORMAT_STEREO16, mixchunk->abuf, mixchunk->alen, 44100);
+    } else {
+        alBufferData(alcc[cache_ch].bufferName, AL_FORMAT_MONO8, mixchunk->abuf, mixchunk->alen, 22050);
+    }
+    alsound_error_check("alBufferData");
+    ret = alGetError();
+
+    if (ret == AL_NO_ERROR) {
+        //Logger->info("alsound_cache        id {}  sz {}  cache_ch {}  flags {}", chunk_id, mixchunk->alen, cache_ch, flags);
+        alcc[cache_ch].size = mixchunk->alen;
+        alcc[cache_ch].id = chunk_id;
+        alcc[cache_ch].flags |= OPENAL_FLG_LOADED;
+    } else {
+        Logger->error("alBufferData() failed: {}", alsound_get_error_str(ret));
+        alcc[cache_ch] = { };
+    }
+}
+
+/// \brief clear all elements of the chunk cache array, used during scene changes
+void alsound_clear_cache(void)
+{
+    int16_t i;
+
+    if (!ale.initialized) {
+        return;
+    }
+
+    //Logger->info("alsound_clear_cache");
+    for (i = OPENAL_C_SZ; i > 0; i--) {
+        if (alc[i - 1].state == AL_PLAYING) {
+            alSourceStop(alc[i - 1].alSource);
+            alsound_error_check("clear_cache alSourceStop");
+            alDeleteSources(1, &alc[i - 1].alSource);
+            alsound_error_check("clear_cache alDeleteSources");
+        } else if (alc[i - 1].state != 0) {
+            alDeleteSources(1, &alc[i - 1].alSource);
+            alsound_error_check("clear_cache alDeleteSources");
+            alc[i - 1].state = 0;
+            //Logger->info("freed {}", i);
+        }
+    }
+
+    for (i = OPENAL_CC_SZ; i > 0; i--) {
+        if (alcc[i - 1].flags & OPENAL_FLG_LOADED) {
+            alDeleteBuffers(1, &alcc[i - 1].bufferName);
+            alsound_error_check("clear_cache alDeleteBuffers");
+        }
+    }
+
+    memset(alc, 0, sizeof(alc));
+    memset(alcc, 0, sizeof(alcc));
+    memset(al_con, 0, sizeof(al_con));
+    ale.scheduling_enabled = 0;
+}
+
+/// \brief place a sound source at the current coordinates
+/// \param chunk_id  sound sample to be played on a continuous loop
+/// \param ssp   optional openal parameters to apply to the source
+/// \return play channel index
+int16_t alsound_create_source(const int16_t chunk_id, al_ssp_t *ssp, event_t *entity)
+{
+    Mix_Chunk mixchunk = { };
+    al_ssp_t ssp_l = { };
+    uint8_t *chunk_data = NULL;
+    int32_t chunk_len;
+
+    if (chunk_id < 0) {
+        return -1;
+    }
+
+    get_sample_ptr((uint8_t) chunk_id, &chunk_data, &chunk_len);
+
+    if (chunk_len < 1000) {
+        Logger->error("alsound_create_source received invalid data");
+        return -1;
+    }
+
+    mixchunk.abuf = chunk_data;
+    mixchunk.alen = chunk_len;
+    mixchunk.volume = 127;
+
+    if (ssp == NULL) {
+        ssp_l.gain = 1.0;
+        ssp_l.reference_distance = 2048.0;
+        ssp_l.max_distance = 65535.0;
+        ssp_l.rolloff_factor = 1.0;
+        ssp_l.coord.x = ale.listener_c.x;
+        ssp_l.coord.y = ale.listener_c.y;
+        ssp_l.coord.z = ale.listener_c.z;
+        return alsound_play(chunk_id, &mixchunk, entity, &ssp_l, AL_FORMAT_MONO8_22050 | AL_TYPE_POSITIONAL);
+    } else {
+        return alsound_play(chunk_id, &mixchunk, entity, ssp, AL_FORMAT_MONO8_22050 | AL_TYPE_POSITIONAL);
+        Logger->info("alsound_create_source {}  at ({},{},{})", mixchunk.alen, ssp->coord.x, ssp->coord.y, ssp->coord.z);
+    }
+}
+
+/// \brief update entity openal source position
+/// \param entity  
+/// \param position   
+void alsound_update_source(event_t *entity)
+{
+    al_ssp_t ssp = { };
+    double dx, dy, dist;
+    uint64_t now = mygetthousandths();
+    uint8_t create_new_source = 0;
+
+    // spread out the scheduled time when the distance needs to be refreshed
+    if (entity->dist_mark == UINT64_MAX) {
+        entity->dist_mark = now + entity->id_0x1A_26;
+    }
+
+    // once every AL_DIST_REFRESH_INTERVAL re-calculate the distance to the listener
+    if (now > entity->dist_mark) {
+        dx = ale.listener_c.x - entity->axis_0x4C_76.x;
+        dy = ale.listener_c.y - entity->axis_0x4C_76.y;
+        dist = sqrt((dx * dx) + (dy * dy));
+        entity->dist = (uint32_t) dist;
+        entity->dist_mark = now + AL_DIST_REFRESH_INTERVAL;
+    }
+
+    // once a while some of the creatures create sounds
+    if ((now > entity->play_mark) && (alcrt[entity->model_0x40_64].chunk_id != -1)) {
+        create_new_source = 1;
+        if (alcrt[entity->model_0x40_64].flags & AL_REPLAY_RARELY) {
+#ifdef _POSIX_C_SOURCE
+            entity->play_mark = now + 5000 + (random() % 32768);
+#else
+            entity->play_mark = now + 5000 + (rand() % 32768);
+#endif
+        } else if (alcrt[entity->model_0x40_64].flags & AL_REPLAY_FREQUENTLY) {
+            entity->play_mark = now;
+        } else {
+#ifdef _POSIX_C_SOURCE
+            entity->play_mark = now + 5000 + (random() % 4098);
+#else
+            entity->play_mark = now + 5000 + (rand() % 4098);
+#endif
+        }
+        //Logger->info("sch     {} @{} in {} ms", entity->id_0x1A_26, entity->play_mark, entity->play_mark - now);
+    }
+
+    if ((entity->dist < AL_DIST_MIN_PLAY) && (alcrt[entity->model_0x40_64].chunk_id != -1)) {
+        if ((entity->play_ch == -1) && create_new_source) {
+            ssp.gain = 0.8f;
+            ssp.reference_distance = 2048.0;
+            if (alcrt[entity->model_0x40_64].flags & AL_POWERFUL_SHOUT) {
+                ssp.gain = 1.0f;
+                ssp.reference_distance = 4096.0;
+            } else if (alcrt[entity->model_0x40_64].flags & AL_WHISPER) {
+                ssp.gain = 0.7f;
+                ssp.reference_distance = 1024.0;
+            }
+            ssp.max_distance = 65535.0;
+            ssp.rolloff_factor = 1.0;
+            ssp.coord.x = entity->axis_0x4C_76.x;
+            ssp.coord.y = entity->axis_0x4C_76.y;
+            ssp.coord.z = entity->axis_0x4C_76.z;
+            //Logger->info("play    {} id {} @{}", creature_name[entity->model_0x40_64], entity->id_0x1A_26, now);
+            entity->play_ch = alsound_create_source(alcrt[entity->model_0x40_64].chunk_id, &ssp, entity);
+        } else if (entity->play_ch != -1) {
+            //Logger->info("update  {} @{}", entity->id_0x1A_26, now);
+            alSource3f(alc[entity->play_ch].alSource, AL_POSITION, entity->axis_0x4C_76.x, entity->axis_0x4C_76.y, entity->axis_0x4C_76.z);
+            //alsound_error_check("alSource3f update_source AL_POSITION");
+        }
+    }
+
+}
+
+/// \brief primary entrypoint for chunks that need to be played
+/// \param chunk_id  chunk identifier
+/// \param mixchunk  SDL2_mixer compatible struct holding chunk data
+/// \param loops 0 for no looping, 0xffff for infinite loop
+/// \param ssp   optional openal parameters to apply to the source. not used by the recode
+/// \return play channel index
+int16_t alsound_play(const int16_t chunk_id, Mix_Chunk *mixchunk, event_t *entity, al_ssp_t *ssp, const uint16_t flags)
+{
+    int16_t i;
+    int16_t cache_ch = -1;
+    int16_t play_ch = -1;
+    float gain = 0.8;           // testing: all sounds produced by recode are at lowered levels
+
+    if (!ale.initialized) {
+        return -1;
+    }
+
+    //Logger->info("alsound_play requested id {}  sz {}  fmt {}", chunk_id, mixchunk->alen, flags);
+
+    // check if sample is already playing too many times atm
+    if (al_con[chunk_id] > oac.same_chunk_concurrency - 1) {
+        //Logger->info("alsound_play ignored id {}", chunk_id);
+        return -1;
+    }
+
+    if (ale.bank < 3) {
+        if ((alct[ale.bank][chunk_id].flags & AL_IGNORE_RECODE) && !(flags & AL_TYPE_POSITIONAL) && 
+        !((ale.listener_c.x == 0) && (ale.listener_c.y == 0) && (ale.listener_c.z == 0))) {
+            return -1;
+        }
+        if (alct[ale.bank][chunk_id].ff_fx > -1) {
+            haptic_run_effect(alct[ale.bank][chunk_id].ff_fx);
+        }
+    }
+
+    // check if chunk has already been cached
+    for (i = OPENAL_CC_SZ; i > 0; i--) {
+        if (alcc[i - 1].id == chunk_id) {
+            cache_ch = i - 1;
+            if (((uint32_t) alcc[i - 1].size != mixchunk->alen) || (chunk_id == OPENAL_CC_SZ - 1)) {
+                //Logger->warn("cache miss!  new {} cached {}  cache_ch {}", mixchunk->alen, alcc[i - 1].size, i - 1);
+                // replace invalid cache slot
+                alsound_cache(cache_ch, chunk_id, mixchunk, flags);
+            }
+            break;
+        }
+    }
+
+    if (cache_ch == -1) {
+        // find an empty cache slot
+        for (i = OPENAL_CC_SZ; i > 0; i--) {
+            if (alcc[i - 1].size == 0) {
+                cache_ch = i - 1;
+                break;
+            }
+        }
+        if (cache_ch == -1) {
+            Logger->error("openal cache is full");
+            return -1;
+        } else {
+            // load chunk into empty cache slot
+            alsound_cache(cache_ch, chunk_id, mixchunk, flags);
+        }
+    }
+
+    // find an empty play slot
+    for (i = OPENAL_C_SZ; i > 0; i--) {
+        if (alc[i - 1].state == 0) {
+            play_ch = i - 1;
+            break;
+        }
+    }
+
+    if (play_ch == -1) {
+        Logger->warn("all channels are used, ignoring chunk");
+        return -1;
+    }
+
+    //Logger->info("alsound_play playing   id {}  sz {}  cache_ch {}  play_ch {}", chunk_id, alcc[cache_ch].size, cache_ch, play_ch);
+
+    if ((alnv.chunk_id == chunk_id) || ((uint32_t) alnv.chunk_id == mixchunk->alen)) {
+        gain = alnv.gain;
+        alnv.chunk_id = -1;     // apply the volume only once
+    }
+
+    if (flags & AL_TYPE_ENV) {
+        gain = (float) oac.env_volume / 127.0f;
+    } else if (flags & AL_TYPE_SPEECH) {
+        gain = (float) oac.speech_volume / 127.0f;
+    }
+
+    alGetError();               // reset global error variable
+    alGenSources((ALuint) 1, &alc[play_ch].alSource);
+    alsound_error_check("alGenSources");
+
+    alSourcef(alc[play_ch].alSource, AL_PITCH, 1);
+    alsound_error_check("alSourcef AL_PITCH");
+    alSource3f(alc[play_ch].alSource, AL_VELOCITY, 0, 0, 0);
+    alsound_error_check("alSource3f AL_VELOCITY");
+
+    if (!ssp) {
+        // no placement received (sound comes from recode)
+        alSourcef(alc[play_ch].alSource, AL_GAIN, gain);
+        alsound_error_check("alSourcef AL_GAIN");
+        alSourcef(alc[play_ch].alSource, AL_REFERENCE_DISTANCE, 512);
+        alsound_error_check("alSourcef AL_REFERENCE_DISTANCE");
+        alSourcef(alc[play_ch].alSource, AL_MAX_DISTANCE, 65535);
+        alsound_error_check("alSourcef AL_MAX_DISTANCE");
+        alSourcef(alc[play_ch].alSource, AL_ROLLOFF_FACTOR, 1.0);
+        alsound_error_check("alSourcef AL_ROLLOFF_FACTOR");
+        alSource3f(alc[play_ch].alSource, AL_POSITION, ale.listener_c.x, ale.listener_c.y, ale.listener_c.z);
+        alsound_error_check("alSource3f listener AL_POSITION");
+        //Logger->info("alsound_play source @({},{},{})", ale.listener_c.x, ale.listener_c.y, ale.listener_c.z);
+    } else {
+        alSourcef(alc[play_ch].alSource, AL_GAIN, ssp->gain);
+        alsound_error_check("alSourcef AL_GAIN");
+        alSourcef(alc[play_ch].alSource, AL_REFERENCE_DISTANCE, ssp->reference_distance);
+        alsound_error_check("alSourcef AL_REFERENCE_DISTANCE");
+        alSourcef(alc[play_ch].alSource, AL_MAX_DISTANCE, ssp->max_distance);
+        alsound_error_check("alSourcef AL_MAX_DISTANCE");
+        alSourcef(alc[play_ch].alSource, AL_ROLLOFF_FACTOR, ssp->rolloff_factor);
+        alsound_error_check("alSourcef AL_ROLLOFF_FACTOR");
+        alSource3f(alc[play_ch].alSource, AL_POSITION, ssp->coord.x, ssp->coord.y, ssp->coord.z);
+        alsound_error_check("alSource3f alSource AL_POSITION");
+        //Logger->info("alsound_play source @({},{},{})", ssp->coord.x, ssp->coord.y, ssp->coord.z);
+    }
+
+//    if (loops == 0xffff) {
+//        alSourcei(alc[play_ch].alSource, AL_LOOPING, AL_TRUE);
+//    } else {
+    alSourcei(alc[play_ch].alSource, AL_LOOPING, AL_FALSE);
+//    }
+    alsound_error_check("alSourcei AL_LOOPING");
+
+    alSourcei(alc[play_ch].alSource, AL_BUFFER, alcc[cache_ch].bufferName);
+    alsound_error_check("alSourcei AL_BUFFER");
+
+    if (ale.efx_initialized) {
+        // assign effect
+        EFXEAXREVERBPROPERTIES reverb;
+
+        if (ale.bank != ale.reverb_type) {
+            // re-initialize the effect to match the current environment
+            alDeleteAuxiliaryEffectSlots(1, &al_slot);
+            alDeleteEffects(1, &al_effect);
+
+            switch (ale.bank) {
+            case AL_BANK_MAP_DAY:
+                reverb = EFX_REVERB_PRESET_GENERIC;
+                break;
+            case AL_BANK_MAP_NIGHT:
+                reverb = EFX_REVERB_PRESET_GENERIC;
+                break;
+            case AL_BANK_MAP_CAVE:
+                reverb = EFX_REVERB_PRESET_CAVE;
+                break;
+            case AL_BANK_MENU:
+            default:
+                reverb = EFX_REVERB_PRESET_GENERIC;
+                break;
+            }
+
+            al_effect = alsound_load_effect(&reverb);
+            if (!al_effect) {
+                Logger->error("OpenAL: cannot load effect");
+            } else {
+                al_slot = 0;
+                alGenAuxiliaryEffectSlots(1, &al_slot);
+                alAuxiliaryEffectSloti(al_slot, AL_EFFECTSLOT_EFFECT, (ALint) al_effect);
+                if (alGetError() == AL_NO_ERROR) {
+                    Logger->trace("alsound_play switched to bank {}", ale.bank);
+                }
+            }
+            ale.reverb_type = ale.bank;
+        }
+
+        alSource3i(alc[play_ch].alSource, AL_AUXILIARY_SEND_FILTER, (ALint) al_slot, 0, AL_FILTER_NULL);
+        alsound_error_check("alSource3i AL_AUXILIARY_SEND_FILTER");
+    }
+
+    alSourcePlay(alc[play_ch].alSource);
+    alsound_error_check("alSourcePlay");
+
+    alc[play_ch].id = chunk_id;
+    alc[play_ch].size = mixchunk->alen;
+
+    alGetSourcei(alc[play_ch].alSource, AL_SOURCE_STATE, &alc[play_ch].state);
+    alsound_error_check("alGetSourcei init");
+
+    alc[play_ch].entity = entity;
+    al_con[chunk_id]++;
+
+    return play_ch;
+}
+
+/// \brief function that determines if a chunk needs to be received as MONO8 22050 or STEREO8 22050
+/// \param chunk_id  chunk identifier
+/// \return AL_FORMAT_STEREO8_22050, AL_FORMAT_MONO8_22050, AL_TYPE_ENV 
+uint16_t alsound_get_chunk_flags(const int16_t chunk_id)
+{
+    int16_t ret = 0;
+
+    if ((ale.bank > AL_BANK_MENU) || (chunk_id > 69) || (chunk_id < 1)) {
+        // not covered
+        ret = 0;
+    } else if (ale.bank == AL_BANK_MENU) {
+        // sound during intro, boulder menu
+        ret = AL_FORMAT_MONO8_22050;
+    } else if (ale.bank < 3) {
+        // sound in day/night/cave locations
+        ret = alct[ale.bank][chunk_id].flags;
+    }
+
+    if (chunk_id == OPENAL_CC_SZ - 1) {
+        ret = AL_FORMAT_STEREO16_44100;
+    }
+
+    return ret;
+}
+
+/// \brief load the given reverb properties into a new OpenAL effect
+/// \param reverb  struct containing reverb parameters
+/// \return an effect identifier or NULL on error
+static ALuint alsound_load_effect(const EFXEAXREVERBPROPERTIES *reverb)
+{
+    ALuint effect = 0;
+    ALenum err;
+
+    alGetError();
+
+    // Create the effect object and check if we can do EAX reverb
+    alGenEffects(1, &effect);
+    alsound_error_check("alGenEffects");
+    if (alGetEnumValue("AL_EFFECT_EAXREVERB") != 0) {
+        Logger->trace("OpenAL: Using EAX Reverb");
+
+        /* EAX Reverb is available. Set the EAX effect type then load the
+         * reverb properties. */
+        alEffecti(effect, AL_EFFECT_TYPE, AL_EFFECT_EAXREVERB);
+        alsound_error_check("alEffecti");
+
+        alEffectf(effect, AL_EAXREVERB_DENSITY, reverb->flDensity);
+        alEffectf(effect, AL_EAXREVERB_DIFFUSION, reverb->flDiffusion);
+        alEffectf(effect, AL_EAXREVERB_GAIN, reverb->flGain);
+        alEffectf(effect, AL_EAXREVERB_GAINHF, reverb->flGainHF);
+        alEffectf(effect, AL_EAXREVERB_GAINLF, reverb->flGainLF);
+        alEffectf(effect, AL_EAXREVERB_DECAY_TIME, reverb->flDecayTime);
+        alEffectf(effect, AL_EAXREVERB_DECAY_HFRATIO, reverb->flDecayHFRatio);
+        alEffectf(effect, AL_EAXREVERB_DECAY_LFRATIO, reverb->flDecayLFRatio);
+        alEffectf(effect, AL_EAXREVERB_REFLECTIONS_GAIN, reverb->flReflectionsGain);
+        alEffectf(effect, AL_EAXREVERB_REFLECTIONS_DELAY, reverb->flReflectionsDelay);
+        alEffectfv(effect, AL_EAXREVERB_REFLECTIONS_PAN, reverb->flReflectionsPan);
+        alEffectf(effect, AL_EAXREVERB_LATE_REVERB_GAIN, reverb->flLateReverbGain);
+        alEffectf(effect, AL_EAXREVERB_LATE_REVERB_DELAY, reverb->flLateReverbDelay);
+        alEffectfv(effect, AL_EAXREVERB_LATE_REVERB_PAN, reverb->flLateReverbPan);
+        alEffectf(effect, AL_EAXREVERB_ECHO_TIME, reverb->flEchoTime);
+        alEffectf(effect, AL_EAXREVERB_ECHO_DEPTH, reverb->flEchoDepth);
+        alEffectf(effect, AL_EAXREVERB_MODULATION_TIME, reverb->flModulationTime);
+        alEffectf(effect, AL_EAXREVERB_MODULATION_DEPTH, reverb->flModulationDepth);
+        alEffectf(effect, AL_EAXREVERB_AIR_ABSORPTION_GAINHF, reverb->flAirAbsorptionGainHF);
+        alEffectf(effect, AL_EAXREVERB_HFREFERENCE, reverb->flHFReference);
+        alEffectf(effect, AL_EAXREVERB_LFREFERENCE, reverb->flLFReference);
+        alEffectf(effect, AL_EAXREVERB_ROOM_ROLLOFF_FACTOR, reverb->flRoomRolloffFactor);
+        alEffecti(effect, AL_EAXREVERB_DECAY_HFLIMIT, reverb->iDecayHFLimit);
+    } else {
+        Logger->trace("OpenAL: Using Standard Reverb");
+
+        /* No EAX Reverb. Set the standard reverb effect type then load the
+         * available reverb properties. */
+        alEffecti(effect, AL_EFFECT_TYPE, AL_EFFECT_REVERB);
+        alsound_error_check("alEffecti");
+
+        alEffectf(effect, AL_REVERB_DENSITY, reverb->flDensity);
+        alEffectf(effect, AL_REVERB_DIFFUSION, reverb->flDiffusion);
+        alEffectf(effect, AL_REVERB_GAIN, reverb->flGain);
+        alEffectf(effect, AL_REVERB_GAINHF, reverb->flGainHF);
+        alEffectf(effect, AL_REVERB_DECAY_TIME, reverb->flDecayTime);
+        alEffectf(effect, AL_REVERB_DECAY_HFRATIO, reverb->flDecayHFRatio);
+        alEffectf(effect, AL_REVERB_REFLECTIONS_GAIN, reverb->flReflectionsGain);
+        alEffectf(effect, AL_REVERB_REFLECTIONS_DELAY, reverb->flReflectionsDelay);
+        alEffectf(effect, AL_REVERB_LATE_REVERB_GAIN, reverb->flLateReverbGain);
+        alEffectf(effect, AL_REVERB_LATE_REVERB_DELAY, reverb->flLateReverbDelay);
+        alEffectf(effect, AL_REVERB_AIR_ABSORPTION_GAINHF, reverb->flAirAbsorptionGainHF);
+        alEffectf(effect, AL_REVERB_ROOM_ROLLOFF_FACTOR, reverb->flRoomRolloffFactor);
+        alEffecti(effect, AL_REVERB_DECAY_HFLIMIT, reverb->iDecayHFLimit);
+    }
+
+    // Check if an error occured, and clean up if so
+    err = alGetError();
+    if (err != AL_NO_ERROR) {
+        Logger->error("OpenAL error: {}", alGetString(err));
+        if (alIsEffect(effect)) {
+            alDeleteEffects(1, &effect);
+        }
+        return 0;
+    }
+
+    return effect;
+}
+
+/// \brief enable scheduling of chunks and thus playing positional audio 
+void alsound_enable_scheduling(void)
+{
+    ale.scheduling_enabled = 1;
+}
+
+/// \brief close down OpenAL, to be used only on program exit
+void alsound_close(void)
+{
+    int16_t i;
+    ALCdevice *device;
+
+    for (i = OPENAL_C_SZ; i > 0; i--) {
+        alDeleteSources(1, &alc[i - 1].alSource);
+    }
+
+    for (i = OPENAL_CC_SZ; i > 0; i--) {
+        if (alcc[i - 1].flags & OPENAL_FLG_LOADED) {
+            alDeleteBuffers(1, &alcc[i - 1].bufferName);
+        }
+    }
+
+    alDeleteAuxiliaryEffectSlots(1, &al_slot);
+    alDeleteEffects(1, &al_effect);
+    device = alcGetContextsDevice(context);
+
+    alcMakeContextCurrent(NULL);
+    alcDestroyContext(context);
+    alcCloseDevice(device);
+}
+
+#ifdef _POSIX_C_SOURCE
+/// \brief save chunk data to a file for debug purposes
+/// \param data  chunk's uint16 wav data
+/// \param len   chunk length in bytes
+uint8_t alsound_save_chunk(uint8_t *data, const uint32_t len, char *filename)
+{
+    char fname[] = "/tmp/remc_XXXXXX";
+    int fd;
+
+    umask(077);
+
+    if (filename == NULL) {
+        fd = mkstemp(fname);
+    } else {
+        fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR);
+    }
+
+    if (fd < 0) {
+        return EXIT_FAILURE;
+    }
+
+    if (write(fd, data, len) != len) {
+        Logger->error("write error: {}", strerror(errno));
+        close(fd);
+        return EXIT_FAILURE;
+    }
+    close(fd);
+    return EXIT_SUCCESS;
+}
+#endif
+
+/// \brief print human-readable OpenAL error codes
+/// \param error  OpenAL error code
+/// \return string containing the error type
+const char *alsound_get_error_str(ALCenum error)
+{
+    switch (error) {
+    case AL_NO_ERROR:
+        return "AL_NO_ERROR";
+    case AL_INVALID_NAME:
+        return "AL_INVALID_NAME";
+    case AL_INVALID_ENUM:
+        return "AL_INVALID_ENUM";
+    case AL_INVALID_VALUE:
+        return "AL_INVALID_VALUE";
+    case AL_INVALID_OPERATION:
+        return "AL_INVALID_OPERATION";
+    case AL_OUT_OF_MEMORY:
+        return "AL_OUT_OF_MEMORY";
+    }
+    return "AL_INVALID_OPERATION";
+}
+
+/// \brief function that is run after an OpenAL function to pick up the error set in a special global variable
+/// \param msg  string to be displayed in case of non-successful operation of the preceding function
+/// \return the error code for further decision-making
+ALCenum alsound_error_check(const char *msg)
+{
+    ALCenum ret;
+
+    ret = alGetError();
+    if (ret != AL_NO_ERROR) {
+        Logger->error("error during {}: {}", msg, alsound_get_error_str(ret));
+        return ret;
+    }
+    return AL_NO_ERROR;
+}
+
+
diff --git a/remc2/portability/port_openal.h b/remc2/portability/port_openal.h
new file mode 100644
index 000000000..6c47ad370
--- /dev/null
+++ b/remc2/portability/port_openal.h
@@ -0,0 +1,64 @@
+#pragma once
+#ifndef PORT_OPENAL_H
+#define PORT_OPENAL_H
+
+#include "AL/al.h"
+
+#define   OPENAL_CHANNELS  24
+#define       OPENAL_C_SZ  OPENAL_CHANNELS     ///< number of chunks that can play at the same time (aka number of voices)
+#define      OPENAL_CC_SZ  128     ///< number of chunks the cache can hold
+
+////< flags used by alsound_set_env()
+#define       AL_SET_BANK  0x1
+
+#define   AL_BANK_MAP_DAY  0x0
+#define AL_BANK_MAP_NIGHT  0x1
+#define  AL_BANK_MAP_CAVE  0x2
+#define      AL_BANK_MENU  0x4
+
+#define   AL_FORMAT_STEREO8_22050  0x01
+#define     AL_FORMAT_MONO8_22050  0x02
+#define  AL_FORMAT_STEREO16_44100  0x04
+#define               AL_TYPE_ENV  0x08
+#define        AL_TYPE_POSITIONAL  0x10
+#define            AL_TYPE_SPEECH  0x20
+#define          AL_IGNORE_RECODE  0x40
+
+#define          AL_REPLAY_RARELY  0x01 // long intervals of silence
+#define      AL_REPLAY_FREQUENTLY  0x02 // short intervals of silence
+#define         AL_POWERFUL_SHOUT  0x04 // controls the reference distance and gain
+#define                AL_WHISPER  0x08 // controls the reference distance and gain
+
+struct al_sound_source_parameters {
+    float gain;
+    float reference_distance;
+    float max_distance;
+    float rolloff_factor;
+    axis_3d coord;
+    axis_4d orient;
+};
+typedef struct al_sound_source_parameters al_ssp_t;
+
+typedef struct _str_0x6E8E event_t;
+
+void alsound_init(void);
+int16_t alsound_play(const int16_t chunk_id, Mix_Chunk *chunk, event_t *entity,
+                     al_ssp_t *ssp, const uint16_t flags);
+void alsound_update(void);
+void alsound_clear_cache(void);
+void alsound_close(void);
+void alsound_set_env(const int32_t value, const uint8_t flag);
+void alsound_set_location(axis_3d *coordinates, axis_4d *orientation);
+void alsound_end_sample(const int32_t chunk_id);
+uint8_t alsound_sample_status(const int32_t chunk_id);
+void alsound_set_sample_volume(const int32_t chunk_id, const int32_t volume);
+uint16_t alsound_get_chunk_flags(const int16_t chunk_id);
+int16_t alsound_create_source(const int16_t chunk_id, al_ssp_t *ssp, event_t *entity);
+void alsound_update_source(event_t *entity);
+void alsound_delete_source(const int16_t ch);
+void alsound_enable_scheduling(void);
+uint8_t alsound_save_chunk(uint8_t *data, const uint32_t len, char *filename);
+
+void alsound_imgui(bool *p_open);
+
+#endif
diff --git a/remc2/portability/port_sdl_joystick.cpp b/remc2/portability/port_sdl_joystick.cpp
index e7d9c7d16..6b00b63a3 100644
--- a/remc2/portability/port_sdl_joystick.cpp
+++ b/remc2/portability/port_sdl_joystick.cpp
@@ -13,29 +13,28 @@
 #include <stdio.h>
 
 #ifdef _MSC_VER
-	#include "SDL.h"
+    #include "SDL.h"
 #else
     #include "SDL2/SDL.h"
 #endif
 
 #include "../engine/sub_main_mouse.h"
 #include "../engine/read_config.h"
-#include "../utilities/Maths.h"
 #include "port_sdl_vga_mouse.h"
 #include "port_sdl_joystick.h"
 
 SDL_Joystick *m_gameController = NULL;
 SDL_Haptic *m_haptic = NULL;
 
-#define              JOY_MIN_X  0   ///< minimum bounds for mouse position value for x axis
-#define              JOY_MIN_Y  0   ///< minimum bounds for mouse position value for y axis
-#define            JOY_NAV_INC  4   ///< coefficient that defines how many pixels to skip while navigating a menu
+#define              JOY_MIN_X  0       ///< minimum bounds for mouse position value for x axis
+#define              JOY_MIN_Y  0       ///< minimum bounds for mouse position value for y axis
+#define            JOY_NAV_INC  4       ///< coefficient that defines how many pixels to skip while navigating a menu
 
-#define       GP_FLIGHT_UPDATE  0x1 ///< bitflag set if the axes controlling flight are out of the stick dead zone
-#define          GP_NAV_UPDATE  0x2 ///< bitflag set if the axes controlling navigation are out of the stick dead zone
-#define          GP_MOV_UPDATE  0x4 ///< bitflag set if the axes controlling movement are out of the stick dead zone
+#define       GP_FLIGHT_UPDATE  0x1     ///< bitflag set if the axes controlling flight are out of the stick dead zone
+#define          GP_NAV_UPDATE  0x2     ///< bitflag set if the axes controlling navigation are out of the stick dead zone
+#define          GP_MOV_UPDATE  0x4     ///< bitflag set if the axes controlling movement are out of the stick dead zone
 
-#define GP_MAX_KEY_RELEASE_ANN  4   ///< maximum number of key release announcements
+#define GP_MAX_KEY_RELEASE_ANN  4       ///< maximum number of key release announcements
 
 ///< simulated key presses
 // to be modified once fully customized 
@@ -47,117 +46,132 @@ SDL_Haptic *m_haptic = NULL;
 #define     GP_KEY_EMU_MINIMAP  0x280d
 #define         GP_KEY_EMU_ESC  0x291b
 #define       GP_KEY_EMU_SPELL  0xe0e0
-#define		  GP_KEY_EMU_PAUSE  0x1370
-#define		  GP_KEY_EMU_SPACE  0x2C20
+#define       GP_KEY_EMU_PAUSE  0x1370
+#define       GP_KEY_EMU_SPACE  0x2C20
 
 ///< structure that defines the current gamepad state ad it's simulated output
 struct gamepad_state {
-	int32_t x;                      ///< currently simulated x mouse position
-	int32_t y;                      ///< currently simulated y mouse position
-	int32_t rest_x;                 ///< mouse x position to use when the stick is in the rest position (or dead zone)
-	int32_t rest_y;                 ///< mouse y position to use when the stick is in the rest position (or dead zone)
-	int32_t max_x;                  ///< maximum bounds for mouse position on the x axis based on current scene (sometimes we get garbage values here from upstream)
-	int32_t max_y;                  ///< maximum bounds for mouse position on the y axis based on current scene (sometimes we get garbage values here from upstream)
-	uint8_t dead_zone_announced;    ///< slow infinite spin mitigation when joystick is in the resting position while in the flying window
-	uint8_t mov_key_announced;      ///< counter of consecutive setPress(false, KEY) requests 
-	uint8_t initialized;            ///< gamepad was initialized and it's ready to be queried
-	uint8_t scene_id;				///< current scene displayed by the recode. one of SCENE_PREAMBLE_MENU, SCENE_FLIGHT, SCENE_FLIGHT_MENU
-	uint8_t nav_mode;               ///< true during menu navigation
-	uint8_t last_trig_fire_R;       ///< detection of movement based on the right trigger button's axis value
-	uint8_t last_trig_fire_L;       ///< detection of movement based on the left trigger button's axis value
+    int32_t x;                  ///< currently simulated x mouse position
+    int32_t y;                  ///< currently simulated y mouse position
+    int32_t rest_x;             ///< mouse x position to use when the stick is in the rest position (or dead zone)
+    int32_t rest_y;             ///< mouse y position to use when the stick is in the rest position (or dead zone)
+    int32_t max_x;              ///< maximum bounds for mouse position on the x axis based on current scene (sometimes we get garbage values here from upstream)
+    int32_t max_y;              ///< maximum bounds for mouse position on the y axis based on current scene (sometimes we get garbage values here from upstream)
+    uint8_t dead_zone_announced;        ///< slow infinite spin mitigation when joystick is in the resting position while in the flying window
+    uint8_t mov_key_announced;  ///< counter of consecutive setPress(false, KEY) requests 
+    uint8_t initialized;        ///< gamepad was initialized and it's ready to be queried
+    uint8_t scene_id;           ///< current scene displayed by the recode. one of SCENE_PREAMBLE_MENU, SCENE_FLIGHT, SCENE_FLIGHT_MENU
+    uint8_t nav_mode;           ///< true during menu navigation
+    uint8_t last_trig_fire_R;   ///< detection of movement based on the right trigger button's axis value
+    uint8_t last_trig_fire_L;   ///< detection of movement based on the left trigger button's axis value
+    int32_t ip_xi_neg;          ///< inflection point, x axis, input, negative side
+    int32_t ip_xi_pos;          ///< inflection point, x axis, input, positive side
+    int32_t ip_yi_neg;          ///< inflection point, y axis, input, negative side
+    int32_t ip_yi_pos;          ///< inflection point, y axis, input, positive side
+    int32_t ip_xo_neg;          ///< inflection point, x axis, output, negative side
+    int32_t ip_xo_pos;          ///< inflection point, x axis, output, positive side
+    int32_t ip_yo_neg;          ///< inflection point, y axis, output, negative side
+    int32_t ip_yo_pos;          ///< inflection point, y axis, output, positive side
 };
 typedef struct gamepad_state gamepad_state_t;
 
 ///< structure that defines the mouse pointer position
 struct pointer_sys {
-	int16_t x;
-	int16_t y;
+    int16_t x;
+    int16_t y;
 };
 typedef struct pointer_sys pointer_sys_t;
 
 ///< hat position data
 struct vec1d {
-	int16_t x;                      ///< bitwise flags. SDL_HAT_UP | SDL_HAT_DOWN | SDL_HAT_LEFT | SDL_HAT_RIGHT or 0
-	uint8_t x_conf;                 ///< bitwise flags. cound be 0 or a combination of GAMEPAD_AXIS_INVERTED | GAMEPAD_ITEM_ENABLED
+    int16_t x;                  ///< bitwise flags. SDL_HAT_UP | SDL_HAT_DOWN | SDL_HAT_LEFT | SDL_HAT_RIGHT or 0
+    uint8_t x_conf;             ///< bitwise flags. cound be 0 or a combination of GAMEPAD_AXIS_INVERTED | GAMEPAD_ITEM_ENABLED
 };
 typedef struct vec1d vec1d_t;
 
 ///< axis position data
 struct vec2d {
-	int16_t x;                      ///< x axis value [-32767..32768]
-	int16_t y;                      ///< y axis value [-32767..32768]
-	uint8_t x_conf;                 ///< bitwise flags. cound be 0 or a combination of GAMEPAD_AXIS_INVERTED | GAMEPAD_ITEM_ENABLED
-	uint8_t y_conf;                 ///< bitwise flags. cound be 0 or a combination of GAMEPAD_AXIS_INVERTED | GAMEPAD_ITEM_ENABLED
+    int16_t x;                  ///< x axis value [-32767..32768]
+    int16_t y;                  ///< y axis value [-32767..32768]
+    uint8_t x_conf;             ///< bitwise flags. cound be 0 or a combination of GAMEPAD_AXIS_INVERTED | GAMEPAD_ITEM_ENABLED
+    uint8_t y_conf;             ///< bitwise flags. cound be 0 or a combination of GAMEPAD_AXIS_INVERTED | GAMEPAD_ITEM_ENABLED
 };
 typedef struct vec2d vec2d_t;
 
 ///< force-feedback subsystem state
 struct haptic_state {
-	uint8_t enabled;                ///< if subsystem is currently enabled
-	uint8_t initialized;            ///< subsystem initialized and ready
-	uint8_t rumble;                 ///< rumble is initialized
-	uint8_t rumble_trig;            ///< rumble trigger is present
-	uint32_t cap;                   ///< controller capabilities
-	int quake;                      ///< quake effect identifier
+    uint8_t enabled;            ///< if subsystem is currently enabled
+    uint8_t initialized;        ///< subsystem initialized and ready
+    uint8_t rumble;             ///< rumble is initialized
+    uint8_t rumble_trig;        ///< rumble trigger is present
+    uint32_t cap;               ///< controller capabilities
+    int effect[GP_HAPTIC_EFFECT_CNT];  ///< haptic effects
 };
 typedef struct haptic_state haptic_state_t;
 
-gamepad_state_t gps = {};
-haptic_state_t hs = {};
+gamepad_state_t gps = { };
+haptic_state_t hs = { };
 
 int8_t haptic_load_effects(void);
+void alsound_enable_scheduling(void); // provide the function signature without including the entire port_openal.h
 
 /// \brief initialization of the SDL joystick subsystem
 void gamepad_sdl_init(void)
 {
-	if (SDL_InitSubSystem(SDL_INIT_JOYSTICK) < 0) {
-		Logger->error("SDL joystick could not be initialized! SDL_Error: {}", SDL_GetError());
-	} else {
-		m_gameController = SDL_JoystickOpen(0);
-		if(m_gameController == NULL) {
-			Logger->debug("joystick/gamepad not detected. SDL Error: {}", SDL_GetError() );
-		} else {
-			Logger->info("Found '{}' joystick", SDL_JoystickName(m_gameController) );
-			if (SDL_JoystickEventState(SDL_ENABLE) != 1) {
-				Logger->error("unable to initialize joystick/gamepad events. SDL Error: {}", SDL_GetError() );
-			} else {
-				gps.initialized = 1;
-			}
-			if (gpc.haptic_enabled && (SDL_InitSubSystem(SDL_INIT_HAPTIC) == 0) && SDL_JoystickIsHaptic(m_gameController)) {
-				m_haptic = SDL_HapticOpenFromJoystick(m_gameController);
-				if (m_haptic == NULL) {
-					Logger->info("unable to init force feedback. SDL Error: {}", SDL_GetError() );
-				} else {
-					hs.cap = SDL_HapticQuery(m_haptic);
-					hs.rumble = SDL_HapticRumbleSupported(m_haptic);
-					//hs.rumble_trig = SDL_JoystickHasRumbleTriggers(m_gameController);
-					hs.initialized = 1;
-					hs.enabled = 1;
-					haptic_load_effects();
-					if (hs.rumble) {
-						if (SDL_HapticRumbleInit(m_haptic) < 0) {
-							hs.rumble = 0;
-						}
-					}
-					if (hs.cap & SDL_HAPTIC_GAIN) {
-						SDL_HapticSetGain(m_haptic, gpc.haptic_gain_max);
-					}
-					Logger->info("found haptic support (cap {}), effect cnt {}, rumble {}, rumble_trig {}", hs.cap, SDL_HapticNumEffects(m_haptic), hs.rumble, hs.rumble_trig);
-				}
-			}
-		}
-	}
+
+    if (SDL_InitSubSystem(SDL_INIT_JOYSTICK) < 0) {
+        Logger->error("SDL joystick could not be initialized! SDL_Error: {}", SDL_GetError());
+    } else {
+        m_gameController = SDL_JoystickOpen(0);
+        if (m_gameController == NULL) {
+            Logger->debug("joystick/gamepad not detected. SDL Error: {}", SDL_GetError());
+        } else {
+            Logger->info("Found '{}' joystick", SDL_JoystickName(m_gameController));
+            if (SDL_JoystickEventState(SDL_ENABLE) != 1) {
+                Logger->error("unable to initialize joystick/gamepad events. SDL Error: {}",
+                              SDL_GetError());
+            } else {
+                gps.initialized = 1;
+            }
+            if (gpc.haptic_enabled && (SDL_InitSubSystem(SDL_INIT_HAPTIC) == 0)
+                && SDL_JoystickIsHaptic(m_gameController)) {
+                m_haptic = SDL_HapticOpenFromJoystick(m_gameController);
+                if (m_haptic == NULL) {
+                    Logger->info("unable to init force feedback. SDL Error: {}", SDL_GetError());
+                } else {
+                    hs.cap = SDL_HapticQuery(m_haptic);
+                    hs.rumble = SDL_HapticRumbleSupported(m_haptic);
+                    //hs.rumble_trig = SDL_JoystickHasRumbleTriggers(m_gameController);
+                    hs.initialized = 1;
+                    hs.enabled = 1;
+                    haptic_load_effects();
+                    if (hs.rumble) {
+                        if (SDL_HapticRumbleInit(m_haptic) < 0) {
+                            hs.rumble = 0;
+                        }
+                    }
+                    if (hs.cap & SDL_HAPTIC_GAIN) {
+                        SDL_HapticSetGain(m_haptic, gpc.haptic_gain_max);
+                    }
+                    Logger->
+                        info
+                        ("found haptic support (cap {}), effect cnt {}, rumble {}, rumble_trig {}",
+                         hs.cap, SDL_HapticNumEffects(m_haptic), hs.rumble, hs.rumble_trig);
+                }
+            }
+        }
+    }
 }
 
 /// \brief cleanup of the SDL joystick subsystem, to be used only on program exit
 void gamepad_sdl_close(void)
 {
-	SDL_JoystickClose(m_gameController);
-	m_gameController = NULL;
-	if (m_haptic) {
-		SDL_HapticClose(m_haptic);
-		m_haptic = NULL;
-	}
+    SDL_JoystickClose(m_gameController);
+    m_gameController = NULL;
+    if (m_haptic) {
+        SDL_HapticClose(m_haptic);
+        m_haptic = NULL;
+    }
 }
 
 /// \brief initialize gamepad maximal coordinate values, default operating mode, etc
@@ -165,71 +179,86 @@ void gamepad_sdl_close(void)
 /// \param gameResHeight maximum y value
 void gamepad_init(const int gameResWidth, const int gameResHeight)
 {
-	gps.max_x = gameResWidth;
-	gps.max_y = gameResHeight;
-	joystick_set_env(gps.max_x >> 1, gps.max_y >> 1);
-	set_scene(SCENE_PREAMBLE_MENU);
-}
-
-void AdjustStickCoords(vec2d_t* stick, std::vector<Maths::Zone>* zonesX, std::vector<Maths::Zone>* zonesY)
-{
-	if (stick->x >= 0)
-	{
-		stick->x = ((int16_t)Maths::CurveCoords(stick->x, stick->x, *zonesX));
-	}
-	else
-	{
-		stick->x = -((int16_t)Maths::CurveCoords(-stick->x, -stick->x, *zonesX));
-	}
-
-	if (stick->y >= 0)
-	{
-		stick->y = ((int16_t)Maths::CurveCoords(stick->y, stick->y, *zonesY));
-	}
-	else
-	{
-		stick->y = -((int16_t)Maths::CurveCoords(-stick->y, -stick->y, *zonesY));
-	}
+    gps.max_x = gameResWidth;
+    gps.max_y = gameResHeight;
+    joystick_set_env(gps.max_x >> 1, gps.max_y >> 1);
+    set_scene(SCENE_PREAMBLE_MENU);
 }
 
 /// \brief flight support via conversion from stick coordinates to pointer coordinates
 /// \param  stick input axis values
 /// \param  point output simulated mouse pointer values
 /// \return 0 if stick is in the dead zone or GP_FLIGHT_UPDATE otherwise
-uint16_t gamepad_axis_flight_conv(vec2d_t *stick, pointer_sys_t *point)
+uint16_t gamepad_axis_flight_conv(const vec2d_t *stick, pointer_sys_t *point)
 {
-	uint16_t ret = 0;
-	AdjustStickCoords(stick, &gpc.axis_yaw_sensitivity, &gpc.axis_pitch_sensitivity);
-	int16_t axis_yaw = stick->x;
-	int16_t axis_pitch = stick->y;
-
-	if ((axis_yaw < gpc.axis_yaw_dead_zone) && (axis_yaw > -gpc.axis_yaw_dead_zone)) {
-		point->x = gps.rest_x;
-	} else {
-		// use two different linear interpolation equations since the
-		// resting coordinate is not always the center of the display
-		if (axis_yaw > 0) {
-			point->x = (((gps.max_x - gps.rest_x) * axis_yaw) >> 15) + gps.rest_x;
-		} else {
-			point->x = ((gps.rest_x * axis_yaw) >> 15) + gps.rest_x;
-		}
-		ret = GP_FLIGHT_UPDATE;
-	}
-
-	if ((axis_pitch < gpc.axis_pitch_dead_zone) && (axis_pitch > -gpc.axis_pitch_dead_zone)) {
-		point->y = gps.rest_y;
-	} else {
-		// use two different linear interpolation equations since the
-		// resting coordinate is not always the center of the display
-		if (axis_pitch > 0) {
-			point->y = (((gps.max_y - gps.rest_y) * axis_pitch) >> 15) + gps.rest_y;
-		} else {
-			point->y = ((gps.rest_y * axis_pitch) >> 15) + gps.rest_y;
-		}
-		ret = GP_FLIGHT_UPDATE;
-	}
-
-	return ret;
+    uint16_t ret = 0;
+    int16_t axis_yaw = stick->x;
+    int16_t axis_pitch = stick->y;
+    float slope, offset, output;
+
+    if ((axis_yaw < gpc.axis_yaw_dead_zone) && (axis_yaw > -gpc.axis_yaw_dead_zone)) {
+        point->x = gps.rest_x;
+    } else {
+        // use two different linear interpolation equations since the
+        // resting coordinate ain't ever the center of the display
+        if (gpc.inflection_x && gpc.inflection_y) {
+            if (axis_yaw < gps.ip_xi_neg) {
+                slope = (float) gps.ip_xo_neg / ((float) gps.ip_xi_neg - -32767.0f);
+                offset = (float) gps.ip_xo_neg - (float) gps.ip_xi_neg * slope;
+                output = slope * axis_yaw + offset;
+                point->x = (int16_t) output;
+            } else if (axis_yaw < 0) {
+                point->x = (gps.rest_x - gps.ip_xo_neg) * axis_yaw / (0 - gps.ip_xi_neg) + gps.rest_x;
+            } else if (axis_yaw < gps.ip_xi_pos) {
+                point->x = (gps.ip_xo_pos - gps.rest_x) * axis_yaw / gps.ip_xi_pos + gps.rest_x;
+            } else {
+                slope = ((float) gps.max_x - (float) gps.ip_xo_pos) / (32768.0f - (float) gps.ip_xi_pos);
+                offset = (float) gps.max_x - 32768.0f * slope;
+                output = slope * axis_yaw + offset;
+                point->x = (int16_t) output;
+            }
+        } else {
+            if (axis_yaw < 0) {
+                point->x = ((gps.rest_x * axis_yaw) >> 15) + gps.rest_x;
+            } else {
+                point->x = (((gps.max_x - gps.rest_x) * axis_yaw) >> 15) + gps.rest_x;
+            }
+        }
+        ret = GP_FLIGHT_UPDATE;
+    }
+
+    if ((axis_pitch < gpc.axis_pitch_dead_zone) && (axis_pitch > -gpc.axis_pitch_dead_zone)) {
+        point->y = gps.rest_y;
+    } else {
+        // use two different linear interpolation equations since the
+        // resting coordinate is not always the center of the display
+        if (gpc.inflection_x && gpc.inflection_y) {
+            if (axis_pitch < gps.ip_yi_neg) {
+                slope = (float) gps.ip_yo_neg / ((float) gps.ip_yi_neg - -32767.0f);
+                offset = (float) gps.ip_yo_neg - (float) gps.ip_yi_neg * slope;
+                output = slope * axis_pitch + offset;
+                point->y = (int16_t) output;
+            } else if (axis_pitch < 0) {
+                point->y = (gps.rest_y - gps.ip_yo_neg) * axis_pitch / (0 - gps.ip_yi_neg) + gps.rest_y;
+            } else if (axis_pitch < gps.ip_yi_pos) {
+                point->y = (gps.ip_yo_pos - gps.rest_y) * axis_pitch / gps.ip_yi_pos + gps.rest_y;
+            } else {
+                slope = ((float) gps.max_y - (float) gps.ip_yo_pos) / (32768.0f - (float) gps.ip_yi_pos);
+                offset = (float) gps.max_y - 32768.0f * slope;
+                output = slope * axis_pitch + offset;
+                point->y = (int16_t) output;
+            }
+        } else {
+            if (axis_pitch > 0) {
+                point->y = (((gps.max_y - gps.rest_y) * axis_pitch) >> 15) + gps.rest_y;
+            } else {
+                point->y = ((gps.rest_y * axis_pitch) >> 15) + gps.rest_y;
+            }
+        }
+        ret = GP_FLIGHT_UPDATE;
+    }
+
+    return ret;
 }
 
 /// \brief menu navigation support via conversion from stick coordinates to pointer coordinates
@@ -238,25 +267,26 @@ uint16_t gamepad_axis_flight_conv(vec2d_t *stick, pointer_sys_t *point)
 /// \return 0 if stick is in the dead zone or GP_NAV_UPDATE otherwise
 uint16_t gamepad_axis_nav_conv(const vec2d_t *stick, pointer_sys_t *point)
 {
-	uint16_t ret = 0;
-	int16_t axis_nav_ns = stick->x;
-	int16_t axis_nav_ew = stick->y;
-
-	if ((axis_nav_ns < gpc.axis_long_nav_dead_zone) && (axis_nav_ns > -gpc.axis_long_nav_dead_zone)) {
-		// point->x remains unchanged
-	} else {
-		point->y += JOY_NAV_INC * (axis_nav_ns >> 13);
-		ret = GP_NAV_UPDATE;
-	}
-
-	if ((axis_nav_ew < gpc.axis_trans_nav_dead_zone) && (axis_nav_ew > -gpc.axis_trans_nav_dead_zone)) {
-		// point->y remains unchanged
-	} else {
-		point->x += JOY_NAV_INC * (axis_nav_ew >> 13);
-		ret = GP_NAV_UPDATE;
-	}
-
-	return ret;
+    uint16_t ret = 0;
+    int16_t axis_nav_ns = stick->x;
+    int16_t axis_nav_ew = stick->y;
+
+    if ((axis_nav_ns < gpc.axis_long_nav_dead_zone) && (axis_nav_ns > -gpc.axis_long_nav_dead_zone)) {
+        // point->x remains unchanged
+    } else {
+        point->y += JOY_NAV_INC * (axis_nav_ns >> 13);
+        ret = GP_NAV_UPDATE;
+    }
+
+    if ((axis_nav_ew < gpc.axis_trans_nav_dead_zone)
+        && (axis_nav_ew > -gpc.axis_trans_nav_dead_zone)) {
+        // point->y remains unchanged
+    } else {
+        point->x += JOY_NAV_INC * (axis_nav_ew >> 13);
+        ret = GP_NAV_UPDATE;
+    }
+
+    return ret;
 }
 
 /// \brief menu navigation support via conversion from hat coordinates to pointer coordinates
@@ -265,138 +295,138 @@ uint16_t gamepad_axis_nav_conv(const vec2d_t *stick, pointer_sys_t *point)
 /// \return 0 if stick is resting or GP_NAV_UPDATE otherwise
 uint16_t gamepad_hat_nav_conv(const vec1d_t *hat, pointer_sys_t *point)
 {
-	uint16_t ret = 0;
-	int16_t inv = 1;
+    uint16_t ret = 0;
+    int16_t inv = 1;
 
-	// dir can be a bitwise OR of two adjacent directions
-	// so don't use 'else if' or 'switch'.
+    // dir can be a bitwise OR of two adjacent directions
+    // so don't use 'else if' or 'switch'.
 
-	if (hat->x_conf & GAMEPAD_AXIS_INVERTED) {
-		inv = -1;
-	}
+    if (hat->x_conf & GAMEPAD_AXIS_INVERTED) {
+        inv = -1;
+    }
 
-	if (hat->x & SDL_HAT_UP) {
-		point->y += inv * JOY_NAV_INC * 2;
-		ret = GP_NAV_UPDATE;
-	}
+    if (hat->x & SDL_HAT_UP) {
+        point->y += inv * JOY_NAV_INC * 2;
+        ret = GP_NAV_UPDATE;
+    }
 
-	if (hat->x & SDL_HAT_DOWN) {
-		point->y -= inv * JOY_NAV_INC * 2;
-		ret = GP_NAV_UPDATE;
-	}
+    if (hat->x & SDL_HAT_DOWN) {
+        point->y -= inv * JOY_NAV_INC * 2;
+        ret = GP_NAV_UPDATE;
+    }
 
-	if (hat->x & SDL_HAT_RIGHT) {
-		point->x += JOY_NAV_INC * 2;
-		ret = GP_NAV_UPDATE;
-	}
+    if (hat->x & SDL_HAT_RIGHT) {
+        point->x += JOY_NAV_INC * 2;
+        ret = GP_NAV_UPDATE;
+    }
 
-	if (hat->x & SDL_HAT_LEFT) {
-		point->x -= JOY_NAV_INC * 2;
-		ret = GP_NAV_UPDATE;
-	}
+    if (hat->x & SDL_HAT_LEFT) {
+        point->x -= JOY_NAV_INC * 2;
+        ret = GP_NAV_UPDATE;
+    }
 
-	return ret;
+    return ret;
 }
 
 /// \brief longitudinal and transversal hat movement converted to hardcoded keyboard keypresses
 /// \param  hat input value
 void gamepad_hat_mov_conv(const vec1d_t *hat)
 {
-	uint16_t ret = 0;
-
-	if (hat->x & SDL_HAT_UP) {
-		setPress(false, GP_KEY_EMU_DOWN);
-		setPress(true, GP_KEY_EMU_UP);
-		ret = GP_MOV_UPDATE;
-	}
-
-	if (hat->x & SDL_HAT_DOWN) {
-		setPress(false, GP_KEY_EMU_UP);
-		setPress(true, GP_KEY_EMU_DOWN);
-		ret = GP_MOV_UPDATE;
-	}
-
-	if (hat->x & SDL_HAT_RIGHT) {
-		setPress(false, GP_KEY_EMU_LEFT);
-		setPress(true, GP_KEY_EMU_RIGHT);
-		ret = GP_MOV_UPDATE;
-	}
-
-	if (hat->x & SDL_HAT_LEFT) {
-		setPress(false, GP_KEY_EMU_RIGHT);
-		setPress(true, GP_KEY_EMU_LEFT);
-		ret = GP_MOV_UPDATE;
-	}
-
-	if (hat->x == 0) {
-		if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
-			setPress(false, GP_KEY_EMU_UP);
-			setPress(false, GP_KEY_EMU_DOWN);
-			setPress(false, GP_KEY_EMU_RIGHT);
-			setPress(false, GP_KEY_EMU_LEFT);
-			gps.mov_key_announced++;
-		}
-	}
-
-	if (ret) {
-		gps.mov_key_announced = 0;
-	}
+    uint16_t ret = 0;
+
+    if (hat->x & SDL_HAT_UP) {
+        setPress(false, GP_KEY_EMU_DOWN);
+        setPress(true, GP_KEY_EMU_UP);
+        ret = GP_MOV_UPDATE;
+    }
+
+    if (hat->x & SDL_HAT_DOWN) {
+        setPress(false, GP_KEY_EMU_UP);
+        setPress(true, GP_KEY_EMU_DOWN);
+        ret = GP_MOV_UPDATE;
+    }
+
+    if (hat->x & SDL_HAT_RIGHT) {
+        setPress(false, GP_KEY_EMU_LEFT);
+        setPress(true, GP_KEY_EMU_RIGHT);
+        ret = GP_MOV_UPDATE;
+    }
+
+    if (hat->x & SDL_HAT_LEFT) {
+        setPress(false, GP_KEY_EMU_RIGHT);
+        setPress(true, GP_KEY_EMU_LEFT);
+        ret = GP_MOV_UPDATE;
+    }
+
+    if (hat->x == 0) {
+        if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
+            setPress(false, GP_KEY_EMU_UP);
+            setPress(false, GP_KEY_EMU_DOWN);
+            setPress(false, GP_KEY_EMU_RIGHT);
+            setPress(false, GP_KEY_EMU_LEFT);
+            gps.mov_key_announced++;
+        }
+    }
+
+    if (ret) {
+        gps.mov_key_announced = 0;
+    }
 }
 
 /// \brief longitudinal and transversal movement via conversion from stick coordinates to key presses
 /// \param  stick input axis values
-void gamepad_axis_mov_conv(vec2d_t *stick)
+void gamepad_axis_mov_conv(const vec2d_t *stick)
 {
-	uint16_t ret = 0;
-	int16_t axis_long_inv = 1;
-	int16_t axis_long = stick->x;
-	int16_t axis_trans = stick->y;
-
-	if (stick->x_conf & GAMEPAD_AXIS_INVERTED) {
-		axis_long_inv = -1;
-	}
-
-	if ((axis_long < gpc.axis_long_dead_zone) && (axis_long > -gpc.axis_long_dead_zone)) {
-		// player seems to always have some inertia, so the following wont't actually stop
-		// longitudinal movement
-		if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
-			setPress(false, GP_KEY_EMU_UP);
-			setPress(false, GP_KEY_EMU_DOWN);
-		}
-	} else {
-		if (axis_long * axis_long_inv > 0) {
-			setPress(false, GP_KEY_EMU_DOWN);
-			setPress(true, GP_KEY_EMU_UP);
-		} else {
-			setPress(false, GP_KEY_EMU_UP);
-			setPress(true, GP_KEY_EMU_DOWN);
-		}
-		ret = GP_MOV_UPDATE;
-	}
-
-	if ((axis_trans < gpc.axis_trans_dead_zone) && (axis_trans > -gpc.axis_trans_dead_zone)) {
-		if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
-			setPress(false, GP_KEY_EMU_RIGHT);
-			setPress(false, GP_KEY_EMU_LEFT);
-		}
-	} else {
-		if (axis_trans > 0) {
-			setPress(false, GP_KEY_EMU_LEFT);
-			setPress(true, GP_KEY_EMU_RIGHT);
-		} else {
-			setPress(false, GP_KEY_EMU_RIGHT);
-			setPress(true, GP_KEY_EMU_LEFT);
-		}
-		ret = GP_MOV_UPDATE;
-	}
-
-	if (!ret) {
-		if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
-			gps.mov_key_announced++;
-		}
-	} else {
-		gps.mov_key_announced = 0;
-	}
+    uint16_t ret = 0;
+    int16_t axis_long_inv = 1;
+    int16_t axis_long = stick->x;
+    int16_t axis_trans = stick->y;
+
+    if (stick->x_conf & GAMEPAD_AXIS_INVERTED) {
+        axis_long_inv = -1;
+    }
+
+    if ((axis_long < gpc.axis_long_dead_zone) && (axis_long > -gpc.axis_long_dead_zone)) {
+        // player seems to always have some inertia, so the following wont't actually stop
+        // longitudinal movement
+        if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
+            setPress(false, GP_KEY_EMU_UP);
+            setPress(false, GP_KEY_EMU_DOWN);
+        }
+    } else {
+        if (axis_long * axis_long_inv > 0) {
+            setPress(false, GP_KEY_EMU_DOWN);
+            setPress(true, GP_KEY_EMU_UP);
+        } else {
+            setPress(false, GP_KEY_EMU_UP);
+            setPress(true, GP_KEY_EMU_DOWN);
+        }
+        ret = GP_MOV_UPDATE;
+    }
+
+    if ((axis_trans < gpc.axis_trans_dead_zone) && (axis_trans > -gpc.axis_trans_dead_zone)) {
+        if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
+            setPress(false, GP_KEY_EMU_RIGHT);
+            setPress(false, GP_KEY_EMU_LEFT);
+        }
+    } else {
+        if (axis_trans > 0) {
+            setPress(false, GP_KEY_EMU_LEFT);
+            setPress(true, GP_KEY_EMU_RIGHT);
+        } else {
+            setPress(false, GP_KEY_EMU_RIGHT);
+            setPress(true, GP_KEY_EMU_LEFT);
+        }
+        ret = GP_MOV_UPDATE;
+    }
+
+    if (!ret) {
+        if (gps.mov_key_announced < GP_MAX_KEY_RELEASE_ANN) {
+            gps.mov_key_announced++;
+        }
+    } else {
+        gps.mov_key_announced = 0;
+    }
 }
 
 /// \brief button-like action via conversion from axis coordinates to a boolean (for xbox trigger buttons)
@@ -404,221 +434,217 @@ void gamepad_axis_mov_conv(vec2d_t *stick)
 /// \return 0 is button is inside the dead zone, 1 otherwise
 void gamepad_axis_bool_conv(const int16_t input, bool *ret)
 {
-	if (input > -32767 + gpc.trigger_dead_zone) {
-		*ret = 1;
-	} else {
-		*ret = 0;
-	}
+    if (input > -32767 + gpc.trigger_dead_zone) {
+        *ret = 1;
+    } else {
+        *ret = 0;
+    }
 }
 
 /// \brief emulate a mouse based on data provided by a gamepad or joystick
 /// \param gpe  gamepad_event_t event strucure populated thru SDL_PollEvent()
 void gamepad_event_mgr(gamepad_event_t *gpe)
 {
-	uint16_t button_state = 0;
-	uint8_t flight_mode = 1; // are we doing flight or menu navigation
-	uint16_t conv_state = 0;
-	pointer_sys_t flight;
-	pointer_sys_t nav;
-	vec2d stick;
-	vec1d hat;
-	bool trig_fire_R = 0, trig_fire_L = 0;
-
-	// decide if we are hadling flight mode or menu navigation mode
-	// default mode, based on scene
-	if (gps.nav_mode) {
-		flight_mode = 0;
-	}
-
-	// overwrite scene-based mode based on what button is pressed
-	if (SDL_JoystickGetButton(m_gameController, gpc.button_spell - 1)) {
-		flight_mode = 0;
-	}
-
-	if (SDL_GetModState() & KMOD_CTRL) {
-		flight_mode = 0;
-	}
-
-	stick.x = gpe->axis_yaw;
-	stick.y = gpe->axis_pitch;
-	flight.x = gps.x;
-	flight.y = gps.y;
-	// flight yaw/pitch is always done via two axes
-	conv_state |= gamepad_axis_flight_conv(&stick, &flight);
-
-	// menu navigation
-	nav.x = gps.x;
-	nav.y = gps.y;
-
-	if (gpc.hat_nav_conf & GAMEPAD_ITEM_ENABLED) {
-		// menu navigation is done via a hat control
-		hat.x = gpe->hat_nav;
-		hat.x_conf = gpc.hat_nav_conf;
-		conv_state |= gamepad_hat_nav_conv(&hat, &nav);
-	} else if (gpc.axis_nav_ns_conf & gpc.axis_nav_ew_conf & GAMEPAD_ITEM_ENABLED) {
-		// menu navigation is done via two axes
-		stick.x = gpe->axis_nav_ns;
-		stick.y = gpe->axis_nav_ew;
-		conv_state |= gamepad_axis_nav_conv(&stick, &nav);
-	}
-
-	if (flight_mode) {
-		gps.x = flight.x;
-		gps.y = flight.y;
-	} else {
-		gps.x = nav.x;
-		gps.y = nav.y;
-	}
-
-	if (gps.x < JOY_MIN_X) {
-		gps.x = JOY_MIN_X;
-	} else if (gps.x > gps.max_x) {
-		gps.x = gps.max_x;
-	}
-
-	if (gps.y < JOY_MIN_Y) {
-		gps.y = JOY_MIN_Y;
-	} else if (gps.y > gps.max_y) {
-		gps.y = gps.max_y;
-	}
-
-	// longitudinal/transversal movement 
-	// (aka forward/back/strafe right/strafe left)
-	if (gpc.hat_mov_conf & GAMEPAD_ITEM_ENABLED) {
-		// if movement is done via a hat
-		hat.x = gpe->hat_mov;
-		hat.x_conf = gpc.hat_mov_conf;
-		gamepad_hat_mov_conv(&hat);
-	}
-
-	if (((gpc.axis_long_conf & GAMEPAD_ITEM_ENABLED) || (gpc.axis_trans_conf & GAMEPAD_ITEM_ENABLED)) && (gps.scene_id != SCENE_SPELL_MENU)) {
-		// if movement is done via two axes
-		stick.x = gpe->axis_long;
-		stick.x_conf = gpc.axis_long_conf;
-		stick.y = gpe->axis_trans;
-		gamepad_axis_mov_conv(&stick);
-	}
-
-	// trigger commands
-	if (gpc.axis_fire_R_conf & GAMEPAD_ITEM_ENABLED) {
-		gamepad_axis_bool_conv(gpe->axis_fire_R, &trig_fire_R);
-		if (trig_fire_R != gps.last_trig_fire_R) {
-			if (trig_fire_R) {
-				button_state |= 0x8;
-			} else {
-				button_state |= 0x10;
-			}
-			gps.last_trig_fire_R = trig_fire_R;
-		}
-	}
-
-	if (gpc.axis_fire_L_conf & GAMEPAD_ITEM_ENABLED) {
-		gamepad_axis_bool_conv(gpe->axis_fire_L, &trig_fire_L);
-		if (trig_fire_L != gps.last_trig_fire_L) {
-			if (trig_fire_L) {
-				button_state |= 0x2;
-			} else {
-				button_state |= 0x4;
-			}
-			gps.last_trig_fire_L = trig_fire_L;
-		}
-	}
-
-	// temporary place for testing haptic effects
-	if (gpe->btn_pressed) {
-		if (gpe->btn_pressed & (1 << gpc.button_fire_R)) {
-			button_state |= 0x8;
-		}
-		if (gpe->btn_pressed & (1 << gpc.button_fire_L)) {
-			button_state |= 0x2;
-			//haptic_rumble_triggers_effect(0, 32000, 1000);
-		}
-		if (gps.scene_id != SCENE_FLIGHT && (gpe->btn_pressed & (1 << gpc.button_menu_select))) {
-			button_state |= 0x2;
-		}
-		if (gps.scene_id != SCENE_FLIGHT_MENU && (gpe->btn_pressed & (1 << gpc.button_spell))) {
-			setPress(true, GP_KEY_EMU_SPELL);
-			//haptic_rumble_triggers_effect(32000, 0, 1000);
-		}
-		if (gpe->btn_pressed & (1 << gpc.button_minimap)) {
-			setPress(true, GP_KEY_EMU_MINIMAP);
-			//haptic_run_effect(hs.quake);
-			//haptic_rumble_effect(0.5, 2000);
-		}
-		if (gpe->btn_pressed & (1 << gpc.button_pause_menu)) {
-			setPress(true, GP_KEY_EMU_PAUSE);
-		}
-		if (gpe->btn_pressed & (1 << gpc.button_fwd)) {
-			setPress(true, GP_KEY_EMU_UP);
-		}
-		if (gpe->btn_pressed & (1 << gpc.button_back)) {
-			setPress(true, GP_KEY_EMU_DOWN);
-		}
-		if (gpe->btn_pressed & (1 << gpc.button_esc)) {
-			setPress(true, GP_KEY_EMU_ESC);
-		}
-		if (gps.scene_id == SCENE_DEAD) {
-			setPress(true, GP_KEY_EMU_SPACE);
-		}
-	}
-
-	if (gpe->btn_released) {
-		if (gpe->btn_released & (1 << gpc.button_fire_R)) {
-			button_state |= 0x10;
-		}
-		if (gpe->btn_released & (1 << gpc.button_fire_L)) {
-			button_state |= 0x4;
-		}
-		if (gps.scene_id != SCENE_FLIGHT && (gpe->btn_released & (1 << gpc.button_menu_select))) {
-			button_state |= 0x4;
-		}
-		if (gps.scene_id != SCENE_FLIGHT_MENU && (gpe->btn_released & (1 << gpc.button_spell))) {
-			setPress(false, GP_KEY_EMU_SPELL);
-		}
-		if (gpe->btn_released & (1 << gpc.button_minimap)) {
-			setPress(false, GP_KEY_EMU_MINIMAP);
-		}
-		if (gpe->btn_released & (1 << gpc.button_pause_menu)) {
-			setPress(false, GP_KEY_EMU_PAUSE);
-		}
-		if (gpe->btn_released & (1 << gpc.button_fwd)) {
-			setPress(false, GP_KEY_EMU_UP);
-		}
-		if (gpe->btn_released & (1 << gpc.button_back)) {
-			setPress(false, GP_KEY_EMU_DOWN);
-		}
-		if (gpe->btn_released & (1 << gpc.button_esc)) {
-			setPress(false, GP_KEY_EMU_ESC);
-		}
-		if (gps.scene_id == SCENE_DEAD) {
-			setPress(false, GP_KEY_EMU_SPACE);
-		}
-	}
-
-	if (gpe->btn_pressed || gpe->btn_released) {
-		Logger->trace("joy pressed {}  released {}  mouse {}", gpe->btn_pressed, gpe->btn_released, button_state);
-	}
-
-	if (button_state) {
-		goto announce;
-	}
-
-	if (conv_state) {
-		gps.dead_zone_announced = 0;
-	} else {
-		if (gps.dead_zone_announced) {
-			// do NOT flood MouseEvents() on frames where the joystick is resting
-			return;
-		} else {
-			gps.dead_zone_announced = 1;
-		}
-	}
-
-announce:
-
-	MouseEvents(button_state & 0x7f, gps.x, gps.y);
-
-	//Logger->info("gpc.axis_dead_zone not big enough fly ({},{}) nav ({},{}) conv_state {}", ge->axis_yaw, ge->axis_pitch, ge->axis_nav_ns, ge->axis_nav_ew, conv_state);
+    uint16_t button_state = 0;
+    uint8_t flight_mode = 1;    // are we doing flight or menu navigation
+    uint16_t conv_state = 0;
+    pointer_sys_t flight;
+    pointer_sys_t nav;
+    vec2d stick;
+    vec1d hat;
+    bool trig_fire_R = 0, trig_fire_L = 0;
+
+    // decide if we are hadling flight mode or menu navigation mode
+    // default mode, based on scene
+    if (gps.nav_mode) {
+        flight_mode = 0;
+    }
+
+    // overwrite scene-based mode based on what button is pressed
+    if (SDL_JoystickGetButton(m_gameController, gpc.button_spell - 1)) {
+        flight_mode = 0;
+    }
+
+    if (SDL_GetModState() & KMOD_CTRL) {
+        flight_mode = 0;
+    }
+
+    stick.x = gpe->axis_yaw;
+    stick.y = gpe->axis_pitch;
+    flight.x = gps.x;
+    flight.y = gps.y;
+    // flight yaw/pitch is always done via two axes
+    conv_state |= gamepad_axis_flight_conv(&stick, &flight);
+
+    // menu navigation
+    nav.x = gps.x;
+    nav.y = gps.y;
+
+    if (gpc.hat_nav_conf & GAMEPAD_ITEM_ENABLED) {
+        // menu navigation is done via a hat control
+        hat.x = gpe->hat_nav;
+        hat.x_conf = gpc.hat_nav_conf;
+        conv_state |= gamepad_hat_nav_conv(&hat, &nav);
+    } else if (gpc.axis_nav_ns_conf & gpc.axis_nav_ew_conf & GAMEPAD_ITEM_ENABLED) {
+        // menu navigation is done via two axes
+        stick.x = gpe->axis_nav_ns;
+        stick.y = gpe->axis_nav_ew;
+        conv_state |= gamepad_axis_nav_conv(&stick, &nav);
+    }
+
+    if (flight_mode) {
+        gps.x = flight.x;
+        gps.y = flight.y;
+    } else {
+        gps.x = nav.x;
+        gps.y = nav.y;
+    }
+
+    if (gps.x < JOY_MIN_X) {
+        gps.x = JOY_MIN_X;
+    } else if (gps.x > gps.max_x) {
+        gps.x = gps.max_x;
+    }
+
+    if (gps.y < JOY_MIN_Y) {
+        gps.y = JOY_MIN_Y;
+    } else if (gps.y > gps.max_y) {
+        gps.y = gps.max_y;
+    }
+
+    // longitudinal/transversal movement 
+    // (aka forward/back/strafe right/strafe left)
+    if (gpc.hat_mov_conf & GAMEPAD_ITEM_ENABLED) {
+        // if movement is done via a hat
+        hat.x = gpe->hat_mov;
+        hat.x_conf = gpc.hat_mov_conf;
+        gamepad_hat_mov_conv(&hat);
+    }
+
+    if (((gpc.axis_long_conf & GAMEPAD_ITEM_ENABLED) || (gpc.axis_trans_conf & GAMEPAD_ITEM_ENABLED)) && (gps.scene_id != SCENE_SPELL_MENU)) {
+        // if movement is done via two axes
+        stick.x = gpe->axis_long;
+        stick.x_conf = gpc.axis_long_conf;
+        stick.y = gpe->axis_trans;
+        gamepad_axis_mov_conv(&stick);
+    }
+
+    // trigger commands
+    if (gpc.axis_fire_R_conf & GAMEPAD_ITEM_ENABLED) {
+        gamepad_axis_bool_conv(gpe->axis_fire_R, &trig_fire_R);
+        if (trig_fire_R != gps.last_trig_fire_R) {
+            if (trig_fire_R) {
+                button_state |= 0x8;
+            } else {
+                button_state |= 0x10;
+            }
+            gps.last_trig_fire_R = trig_fire_R;
+        }
+    }
+
+    if (gpc.axis_fire_L_conf & GAMEPAD_ITEM_ENABLED) {
+        gamepad_axis_bool_conv(gpe->axis_fire_L, &trig_fire_L);
+        if (trig_fire_L != gps.last_trig_fire_L) {
+            if (trig_fire_L) {
+                button_state |= 0x2;
+            } else {
+                button_state |= 0x4;
+            }
+            gps.last_trig_fire_L = trig_fire_L;
+        }
+    }
+
+    if (gpe->btn_pressed) {
+        if (gpe->btn_pressed & ((uint64_t) 1 << gpc.button_fire_R)) {
+            button_state |= 0x8;
+        }
+        if (gpe->btn_pressed & ((uint64_t) 1 << gpc.button_fire_L)) {
+            button_state |= 0x2;
+        }
+        if (gps.scene_id != SCENE_FLIGHT && (gpe->btn_pressed & (1 << gpc.button_menu_select))) {
+            button_state |= 0x2;
+        }
+        if (gps.scene_id != SCENE_FLIGHT_MENU && (gpe->btn_pressed & (1 << gpc.button_spell))) {
+            setPress(true, GP_KEY_EMU_SPELL);
+        }
+        if (gpe->btn_pressed & ((uint64_t) 1 << gpc.button_minimap)) {
+            setPress(true, GP_KEY_EMU_MINIMAP);
+        }
+        if (gpe->btn_pressed & ((uint64_t) 1 << gpc.button_pause_menu)) {
+            setPress(true, GP_KEY_EMU_PAUSE);
+        }
+        if (gpe->btn_pressed & ((uint64_t) 1 << gpc.button_fwd)) {
+            setPress(true, GP_KEY_EMU_UP);
+        }
+        if (gpe->btn_pressed & ((uint64_t) 1 << gpc.button_back)) {
+            setPress(true, GP_KEY_EMU_DOWN);
+        }
+        if (gpe->btn_pressed & ((uint64_t) 1 << gpc.button_esc)) {
+            setPress(true, GP_KEY_EMU_ESC);
+        }
+        if (gps.scene_id == SCENE_DEAD) {
+            setPress(true, GP_KEY_EMU_SPACE);
+        }
+    }
+
+    if (gpe->btn_released) {
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_fire_R)) {
+            button_state |= 0x10;
+        }
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_fire_L)) {
+            button_state |= 0x4;
+        }
+        if (gps.scene_id != SCENE_FLIGHT && (gpe->btn_released & (1 << gpc.button_menu_select))) {
+            button_state |= 0x4;
+        }
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_spell)) {
+            setPress(false, GP_KEY_EMU_SPELL);
+        }
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_minimap)) {
+            setPress(false, GP_KEY_EMU_MINIMAP);
+        }
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_pause_menu)) {
+            setPress(false, GP_KEY_EMU_PAUSE);
+        }
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_fwd)) {
+            setPress(false, GP_KEY_EMU_UP);
+        }
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_back)) {
+            setPress(false, GP_KEY_EMU_DOWN);
+        }
+        if (gpe->btn_released & ((uint64_t) 1 << gpc.button_esc)) {
+            setPress(false, GP_KEY_EMU_ESC);
+        }
+        if (gps.scene_id == SCENE_DEAD) {
+            setPress(false, GP_KEY_EMU_SPACE);
+        }
+    }
+
+    if (gpe->btn_pressed || gpe->btn_released) {
+        Logger->trace("joy pressed {}  released {}  mouse {}", gpe->btn_pressed, gpe->btn_released,
+                      button_state);
+    }
+
+    if (button_state) {
+        goto announce;
+    }
+
+    if (conv_state) {
+        gps.dead_zone_announced = 0;
+    } else {
+        if (gps.dead_zone_announced) {
+            // do NOT flood MouseEvents() on frames where the joystick is resting
+            return;
+        } else {
+            gps.dead_zone_announced = 1;
+        }
+    }
+
+ announce:
+
+    MouseEvents(button_state & 0x7f, gps.x, gps.y);
+
+    //Logger->info("gpc.axis_dead_zone not big enough fly ({},{}) nav ({},{}) conv_state {}", ge->axis_yaw, ge->axis_pitch, ge->axis_nav_ns, ge->axis_nav_ew, conv_state);
 }
 
 /// \brief once per frame read out all axes and hats, for perfect smoothness
@@ -626,87 +652,106 @@ announce:
 void gamepad_poll_data(gamepad_event_t *gpe)
 {
 
-	if (!gps.initialized) {
-		return;
-	}
+    if (!gps.initialized) {
+        return;
+    }
+
+    // make sure to poll for the axis data on every single frame
+    // otherwise we get janky movement since there is no event
+    // if the joystick is held still outside the rest position
 
-	// make sure to poll for the axis data on every single frame
-	// otherwise we get janky movement since there is no event
-	// if the joystick is held still outside the rest position
+    if (gpc.axis_yaw_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_yaw = SDL_JoystickGetAxis(m_gameController, gpc.axis_yaw);
+    }
 
-	if (gpc.axis_yaw_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->axis_yaw = SDL_JoystickGetAxis(m_gameController, gpc.axis_yaw);
-	}
+    if (gpc.axis_pitch_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_pitch = SDL_JoystickGetAxis(m_gameController, gpc.axis_pitch);
+    }
 
-	if (gpc.axis_pitch_conf & GAMEPAD_ITEM_ENABLED)  {
-		gpe->axis_pitch = SDL_JoystickGetAxis(m_gameController, gpc.axis_pitch);
-	}
+    if (gpc.axis_long_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_long = SDL_JoystickGetAxis(m_gameController, gpc.axis_long);
+    }
 
-	if (gpc.axis_long_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->axis_long = SDL_JoystickGetAxis(m_gameController, gpc.axis_long);
-	}
+    if (gpc.axis_trans_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_trans = SDL_JoystickGetAxis(m_gameController, gpc.axis_trans);
+    }
 
-	if (gpc.axis_trans_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->axis_trans = SDL_JoystickGetAxis(m_gameController, gpc.axis_trans);
-	}
+    if (gpc.axis_nav_ns_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_nav_ns = SDL_JoystickGetAxis(m_gameController, gpc.axis_nav_ns);
+    }
 
-	if (gpc.axis_nav_ns_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->axis_nav_ns = SDL_JoystickGetAxis(m_gameController, gpc.axis_nav_ns);
-	}
+    if (gpc.axis_nav_ew_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_nav_ew = SDL_JoystickGetAxis(m_gameController, gpc.axis_nav_ew);
+    }
 
-	if (gpc.axis_nav_ew_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->axis_nav_ew = SDL_JoystickGetAxis(m_gameController, gpc.axis_nav_ew);
-	}
+    if (gpc.hat_nav_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->hat_nav = SDL_JoystickGetHat(m_gameController, gpc.hat_nav);
+    }
 
-	if (gpc.hat_nav_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->hat_nav = SDL_JoystickGetHat(m_gameController, gpc.hat_nav);
-	}
+    if (gpc.hat_mov_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->hat_mov = SDL_JoystickGetHat(m_gameController, gpc.hat_mov);
+    }
 
-	if (gpc.hat_mov_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->hat_mov = SDL_JoystickGetHat(m_gameController, gpc.hat_mov);
-	}
+    if (gpc.axis_fire_R_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_fire_R = SDL_JoystickGetAxis(m_gameController, gpc.axis_fire_R);
+    }
 
-	if (gpc.axis_fire_R_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->axis_fire_R = SDL_JoystickGetAxis(m_gameController, gpc.axis_fire_R);
-	}
+    if (gpc.axis_fire_L_conf & GAMEPAD_ITEM_ENABLED) {
+        gpe->axis_fire_L = SDL_JoystickGetAxis(m_gameController, gpc.axis_fire_L);
+    }
 
-	if (gpc.axis_fire_L_conf & GAMEPAD_ITEM_ENABLED) {
-		gpe->axis_fire_L = SDL_JoystickGetAxis(m_gameController, gpc.axis_fire_L);
-	}
+    // call the event handler only once per frame not inside the SDL_PollEvent() loop
+    // https://stackoverflow.com/questions/39376356/non-instantaneous-jerky-movement-using-sdl2-opengl
+    gamepad_event_mgr(gpe);
+}
 
-	// call the event handler only once per frame not inside the SDL_PollEvent() loop
-	// https://stackoverflow.com/questions/39376356/non-instantaneous-jerky-movement-using-sdl2-opengl
-	gamepad_event_mgr(gpe);
+void calc_inflection(void)
+{
+    gps.ip_xi_neg = (-32767 * gpc.inflection_x + 50) / 100;
+    gps.ip_xi_pos = (32768 * gpc.inflection_x + 50) / 100;
+    gps.ip_xo_neg = (gps.rest_x * gpc.inflection_y + 50) / 100;
+    gps.ip_xo_pos = gps.max_x - ((gps.max_x - gps.rest_x) * gpc.inflection_y + 50) / 100;
+
+    gps.ip_yi_neg = gps.ip_xi_neg;
+    gps.ip_yi_pos = gps.ip_xi_pos;
+    gps.ip_yo_neg = (gps.rest_y * gpc.inflection_y + 50) / 100;
+    gps.ip_yo_pos = gps.max_y - ((gps.max_y - gps.rest_y) * gpc.inflection_y + 50) / 100;
 }
 
 /// \brief reconfigure gamepad maximum coverage and operating mode based on recode scene
 /// \param scene_id one of SCENE_PREAMBLE_MENU, SCENE_FLIGHT, SCENE_FLIGHT_MENU
 void set_scene(const uint8_t scene_id)
 {
-	gps.scene_id = scene_id;
-	switch (scene_id) {
-		case SCENE_PREAMBLE_MENU:
-			gps.max_x = 640;
-			gps.max_y = 480;
-			gps.nav_mode = 1;
-			break;
-		case SCENE_FLIGHT:
-			gps.max_x = gameResWidth;
-			gps.max_y = gameResHeight;
-			gps.nav_mode = 0;
-			break;
-		case SCENE_FLIGHT_MENU:
-		case SCENE_SPELL_MENU:
-			gps.max_x = gameResWidth;
-			gps.max_y = gameResHeight;
-			gps.nav_mode = 1;
-			break;
-		default:
-			gps.max_x = gameResWidth;
-			gps.max_y = gameResHeight;
-			break;
-	}
-	Logger->trace("set scene {}, nav_mode {}", scene_id, gps.nav_mode);
+    gps.scene_id = scene_id;
+    switch (scene_id) {
+    case SCENE_PREAMBLE_MENU:
+        gps.max_x = 640;
+        gps.max_y = 480;
+        gps.nav_mode = 1;
+        break;
+    case SCENE_FLIGHT:
+        gps.max_x = gameResWidth;
+        gps.max_y = gameResHeight;
+        gps.nav_mode = 0;
+#ifdef SOUND_OPENAL
+        alsound_enable_scheduling();
+#endif
+        break;
+    case SCENE_FLIGHT_MENU:
+    case SCENE_SPELL_MENU:
+        gps.max_x = gameResWidth;
+        gps.max_y = gameResHeight;
+        gps.nav_mode = 1;
+        break;
+    default:
+        gps.max_x = gameResWidth;
+        gps.max_y = gameResHeight;
+        break;
+    }
+    Logger->trace("set scene {}, nav_mode {}", scene_id, gps.nav_mode);
+    if (gpc.inflection_x && gpc.inflection_y) {
+        calc_inflection();
+    }
 }
 
 /// \brief set the x,y simulated mouse pointer coordinates of the joystick rest position
@@ -714,74 +759,105 @@ void set_scene(const uint8_t scene_id)
 /// \param y coordinate
 void joystick_set_env(const int32_t x, const int32_t y)
 {
-	Logger->trace("pointer rest at {},{} scene {}, window size {},{}", x, y, gps.scene_id, gps.max_x, gps.max_y);
-	gps.rest_x = x;
-	gps.rest_y = y;
-	gps.x = x;
-	gps.y = y;
+    //Logger->info("pointer rest at {},{} scene {}, window size {},{}", x, y, gps.scene_id, gps.max_x, gps.max_y);
+    gps.rest_x = x;
+    gps.rest_y = y;
+    gps.x = x;
+    gps.y = y;
+    if (gpc.inflection_x && gpc.inflection_y) {
+        calc_inflection();
+    }
 }
 
 /// \brief unfinished load effects to be sent to the haptic subsystem
 /// \return EXIT_FAILURE on error, EXIT_SUCCESS otherwise
-int8_t haptic_load_effects(void) {
-	SDL_HapticEffect effect;
-	int16_t max_effects = 0;
-
-	if ((hs.cap & SDL_HAPTIC_SINE)==0) {
-		Logger->info("haptic sine not supported");
-		return EXIT_FAILURE;
-	}
-
-	max_effects = SDL_HapticNumEffects(m_haptic);
-	if (max_effects < 0) {
-		Logger->info("SDL_HapticNumEffects() error {}", SDL_GetError());
-	}
-
-	// quake effect
-	SDL_memset( &effect, 0, sizeof(SDL_HapticEffect) ); // 0 is safe default
-	effect.type = SDL_HAPTIC_SINE;
-	effect.periodic.direction.type = SDL_HAPTIC_POLAR; // polar coordinates
-	effect.periodic.direction.dir[0] = 18000; // force comes from south
-	effect.periodic.period = 1000; // time in ms
-	effect.periodic.magnitude = 10000; // out of 32767 strength
-	effect.periodic.length = 3000; // time in ms
-	effect.periodic.attack_length = 1000; // takes 1 second to get max strength
-	effect.periodic.fade_length = 1000; // takes 1 second to fade away
-
-	hs.quake = SDL_HapticNewEffect(m_haptic, &effect);
-
-	return EXIT_SUCCESS;
+int8_t haptic_load_effects(void)
+{
+    SDL_HapticEffect effect;
+    int16_t max_effects = 0;
+
+    if ((hs.cap & SDL_HAPTIC_SINE) == 0) {
+        Logger->info("haptic sine not supported");
+        return EXIT_FAILURE;
+    }
+
+    max_effects = SDL_HapticNumEffects(m_haptic);
+    if (max_effects < 0) {
+        Logger->info("SDL_HapticNumEffects() error {}", SDL_GetError());
+    }
+
+    // meteor effect
+    SDL_memset(&effect, 0, sizeof(SDL_HapticEffect));
+    effect.type = SDL_HAPTIC_SINE;
+    effect.periodic.direction.type = SDL_HAPTIC_POLAR; // polar coordinates
+    effect.periodic.direction.dir[0] = rand() % 36000; // force direction
+    effect.periodic.period = 1000;      // time in ms
+    effect.periodic.magnitude = 32000;  // out of 32767 strength
+    effect.periodic.length = 300;       // time in ms
+    effect.periodic.attack_length = 100;// interval until max strength
+    effect.periodic.fade_length = 100;  // fade away interval
+    hs.effect[GP_HAPTIC_METEOR] = SDL_HapticNewEffect(m_haptic, &effect);
+
+    // quake effect
+    SDL_memset(&effect, 0, sizeof(SDL_HapticEffect));
+    effect.type = SDL_HAPTIC_SINE;
+    effect.periodic.direction.type = SDL_HAPTIC_POLAR;  // polar coordinates
+    effect.periodic.direction.dir[0] = rand() % 36000;  // force direction
+    effect.periodic.period = 1000;       // time in ms
+    effect.periodic.magnitude = 5000;    // carpet is floating, so suspension is great
+    effect.periodic.length = 3000;       // time in ms
+    effect.periodic.attack_length = 1000;// interval until max strength
+    effect.periodic.fade_length = 1000;  // fade away interval
+    hs.effect[GP_HAPTIC_QUAKE] = SDL_HapticNewEffect(m_haptic, &effect);
+
+    // tornado effect
+    SDL_memset(&effect, 0, sizeof(SDL_HapticEffect));   // 0 is safe default
+    effect.type = SDL_HAPTIC_SINE;
+    effect.periodic.direction.type = SDL_HAPTIC_POLAR;  // polar coordinates
+    effect.periodic.direction.dir[0] = rand() % 36000;  // force direction
+    effect.periodic.period = 1000;       // time in ms
+    effect.periodic.magnitude = 20000;   // out of 32767 strength
+    effect.periodic.length = 3200;       // time in ms
+    effect.periodic.attack_length = 2000;// interval until max strength
+    effect.periodic.fade_length = 1000;  // fade away interval
+    hs.effect[GP_HAPTIC_TORNADO] = SDL_HapticNewEffect(m_haptic, &effect);
+
+    return EXIT_SUCCESS;
 }
 
 /// \brief send sine-based effect to the haptic subsystem
 /// \param effect_id  identifier
-void haptic_run_effect(const int effect_id) {
-	if (!hs.enabled || ((hs.cap & SDL_HAPTIC_SINE)==0)) {
-		return;
-	}
-	Logger->info("run_effect {}", effect_id);
-	SDL_HapticRunEffect(m_haptic, effect_id, 1);
+void haptic_run_effect(const int effect_id)
+{
+    if (!hs.enabled || ((hs.cap & SDL_HAPTIC_SINE) == 0)) {
+        return;
+    }
+    //Logger->info("run_effect {}", effect_id);
+    SDL_HapticRunEffect(m_haptic, effect_id, 1);
 }
 
 /// \brief send rumble effect to the haptic subsystem
 /// \param strength defined in the [0-1.0] interval
 /// \param length  effect duration in ms
-void haptic_rumble_effect(const float strength, const uint32_t length) {
-	if ((!hs.enabled) || (!hs.rumble)) {
-		return;
-	}
-	Logger->info("run_rumble {},{}", strength, length);
-	SDL_HapticRumblePlay(m_haptic, strength, length);
+void haptic_rumble_effect(const float strength, const uint32_t length)
+{
+    if ((!hs.enabled) || (!hs.rumble)) {
+        return;
+    }
+    Logger->info("run_rumble {},{}", strength, length);
+    SDL_HapticRumblePlay(m_haptic, strength, length);
 }
 
 /// \brief send rumble effect to the trigger buttons
 /// \param strength_l TL effect level
 /// \param strength_r TR effect level
 /// \param length effect duration in ms
-void haptic_rumble_triggers_effect(const uint16_t strength_l, const uint16_t strength_r, const uint32_t length) {
-	if ((!hs.enabled) || (!hs.rumble_trig)) {
-		return;
-	}
-	//SDL_JoystickRumbleTriggers(m_gameController, strength_l, strength_r, length);
+void haptic_rumble_triggers_effect(const uint16_t strength_l, const uint16_t strength_r,
+                                   const uint32_t length)
+{
+    if ((!hs.enabled) || (!hs.rumble_trig)) {
+        return;
+    }
+    SDL_JoystickRumbleTriggers(m_gameController, strength_l, strength_r, length);
 }
 
diff --git a/remc2/portability/port_sdl_joystick.h b/remc2/portability/port_sdl_joystick.h
index 111de394e..60bddd53e 100644
--- a/remc2/portability/port_sdl_joystick.h
+++ b/remc2/portability/port_sdl_joystick.h
@@ -2,6 +2,7 @@
 #ifndef PORT_SDL_JOYSTICK_H
 #define PORT_SDL_JOYSTICK_H
 
+///< possible scenes
 #define  SCENE_PREAMBLE_MENU  0x1
 #define         SCENE_FLIGHT  0x2
 #define    SCENE_FLIGHT_MENU  0x3
@@ -12,20 +13,26 @@
 #define      GP_BTN_RELEASED  0x40
 #define       GP_BTN_PRESSED  0x80
 
+///< haptic effect array index
+#define     GP_HAPTIC_METEOR  0x0
+#define      GP_HAPTIC_QUAKE  0x1
+#define    GP_HAPTIC_TORNADO  0x2
+#define GP_HAPTIC_EFFECT_CNT  0x3  ///< update this one to last effect count+1 !
+
 struct gamepad_event {
-	int16_t axis_yaw;
-	int16_t axis_pitch;
-	int16_t axis_long;
-	int16_t axis_trans;
-	int16_t axis_nav_ns;
-	int16_t axis_nav_ew;
-	int16_t axis_fire_R;
-	int16_t axis_fire_L;
-	uint8_t hat_nav;
-	uint8_t hat_mov;
-	uint64_t btn_released;  ///< bitwise OR of every released button
-	uint64_t btn_pressed;   ///< bitwise OR of every pressed button
-	uint8_t flag;           ///< bitwise OR of every parameter that was updated
+    int16_t axis_yaw;
+    int16_t axis_pitch;
+    int16_t axis_long;
+    int16_t axis_trans;
+    int16_t axis_nav_ns;
+    int16_t axis_nav_ew;
+    int16_t axis_fire_R;
+    int16_t axis_fire_L;
+    uint8_t hat_nav;
+    uint8_t hat_mov;
+    uint64_t btn_released;      ///< bitwise OR of every released button
+    uint64_t btn_pressed;       ///< bitwise OR of every pressed button
+    uint8_t flag;               ///< bitwise OR of every parameter that was updated
 };
 typedef struct gamepad_event gamepad_event_t;
 
@@ -34,10 +41,13 @@ void joystick_set_env(const int32_t x, const int32_t y);
 void gamepad_sdl_init(void);
 void gamepad_sdl_close(void);
 void gamepad_init(const int gameResWidth, const int gameResHeight);
-void gamepad_poll_data(gamepad_event_t *gpe);
+void gamepad_poll_data(gamepad_event_t * gpe);
 
 void haptic_run_effect(const int effect_id);
 void haptic_rumble_effect(const float strength, const uint32_t length);
-void haptic_rumble_triggers_effect(const uint16_t strength_l, const uint16_t strength_r, const uint32_t length);
+void haptic_rumble_triggers_effect(const uint16_t strength_l, const uint16_t strength_r,
+                                   const uint32_t length);
+
+void controller_imgui(bool *p_open);
 
-#endif //PORT_SDL_JOYSTICK
+#endif                          //PORT_SDL_JOYSTICK
diff --git a/remc2/portability/port_sdl_sound.cpp b/remc2/portability/port_sdl_sound.cpp
index 9262eda40..aa61f8e10 100644
--- a/remc2/portability/port_sdl_sound.cpp
+++ b/remc2/portability/port_sdl_sound.cpp
@@ -1,23 +1,24 @@
+#include <iostream>
+#include <fcntl.h>
 #include "../engine/engine_support.h"
+#include "port_openal.h"
 #include "port_sdl_sound.h"
 
-#include <adlmidi.h>
-#include <iostream>
-
 #ifdef __linux__
-    #include <limits>
-    #define MAX_PATH PATH_MAX
+#include <limits>
+#define MAX_PATH PATH_MAX
 #endif
 
 /*This source code copyrighted by Lazy Foo' Productions (2004-2013)
 and may not be redistributed without written permission.*/
 
-bool debug_first_sound=true;
+bool debug_first_sound = true;
 
-bool hqsound=false;
-bool oggmusic=false;
+bool hqsound = false;
+bool oggmusic = false;
 bool oggmusicalternative = false;
 char oggmusicFolder[512];
+char speech_folder[512];
 
 bool fixspeedsound = false;
 
@@ -29,18 +30,17 @@ int num_IO_configurations = 3;
 int service_rate = -1;
 int master_volume = -1;
 
-//The music that will be played
 #ifdef SOUND_SDLMIXER
-Mix_Music* GAME_music[20] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL };
-#endif//SOUND_SDLMIXER
-#ifdef SOUND_OPENAL
-//Mix_Music* GAME_music[20] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL };
-ALint source_state[32];
-ALuint alSource[32];      //source
-ALuint alSampleSet[32];
-#endif//SOUND_OPENAL
-Mix_Chunk gamechunk[32];
-HSAMPLE gamechunkHSAMPLE[32];
+Mix_Music *GAME_music[20] =
+    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL
+};
+#endif
+
+Mix_Chunk gamechunk[32];        //OPENAL_CHANNELS];
+HSAMPLE gamechunkHSAMPLE[32];   //OPENAL_CHANNELS];
+
+extern char x_BYTE_E2A28_speech;
 
 uint8_t sound_buffer[4][20000];
 /*
@@ -60,1141 +60,516 @@ uint8_t sound_buffer[4][20000];
  2
 
 */
-void test_midi_play(uint8_t*  /*data*/, uint8_t* header, int32_t track_number)
-{
-	uint8_t* acttrack = &header[32 + track_number * 32];
-	//int testsize = *(uint32_t*)(&header[32 + (track_number + 1) * 32] + 18) - *(uint32_t*)(acttrack + 18);
-	int testsize2 = *(uint32_t*)(acttrack + 26);
-
-	//unsigned char* TranscodeXmiToMid(const unsigned char* pXmiData,	size_t iXmiLength, size_t* pMidLength);
-	size_t iXmiLength = testsize2;
-	size_t pMidLength;
-	uint8_t* outmidi = TranscodeXmiToMid((const uint8_t*)*(uint32_t*)(acttrack + 18), iXmiLength, &pMidLength);
-	SDL_RWops* rwmidi = SDL_RWFromMem(outmidi, pMidLength);
-
-	//Timidity_Init();
-	if (track_number > 20)
-	{
-		exit(0);
-	}
-#ifdef SOUND_SDLMIXER
-	GAME_music[track_number] = Mix_LoadMUSType_RW(rwmidi, MUS_MID, SDL_TRUE);
-#endif//SOUND_SDLMIXER
-	//music2 = Mix_LoadMUSType_RW(rwmidi, MIX_MUSIC_TIMIDITY, SDL_TRUE);
-	playmusic2(track_number);
-}
 
-void SOUND_start_sequence(int32_t sequence_num) {
-	if (unitTests)return;
-	//3 - menu
-	//4 - intro
+void SOUND_start_sequence(int32_t sequence_num)
+{
+    if (unitTests)
+        return;
+    //3 - menu
+    //4 - intro
 #ifdef SOUND_SDLMIXER
-	last_sequence_num = sequence_num;
-	//volume fix
-	if (lastMusicVolume == -1)
-	{
-		SOUND_set_sequence_volume(0x64, 0);
-	}
-	if (lastMusicVolume != settingsMusicVolume)
-	{
-		SOUND_set_sequence_volume(settingsMusicVolume, 0);
-	}
-	//volume fix
-
-	if (Mix_PlayingMusic() == 0)
-	{
-		if (Mix_PlayMusic(GAME_music[sequence_num], -1) == -1)
-			if (Mix_PausedMusic() == 1)
-			{
-				Mix_ResumeMusic();
-			}
-			else
-			{
-				Mix_PauseMusic();
-			}
-	}
-#endif//SOUND_SDLMIXER
+    last_sequence_num = sequence_num;
+    //volume fix
+    if (lastMusicVolume == -1) {
+        SOUND_set_sequence_volume(0x64, 0);
+    }
+    if (lastMusicVolume != settingsMusicVolume) {
+        SOUND_set_sequence_volume(settingsMusicVolume, 0);
+    }
+    //volume fix
+
+    if (Mix_PlayingMusic() == 0) {
+        if (Mix_PlayMusic(GAME_music[sequence_num], -1) == -1)
+            if (Mix_PausedMusic() == 1) {
+                Mix_ResumeMusic();
+            } else {
+                Mix_PauseMusic();
+            }
+    }
+#endif                          //SOUND_SDLMIXER
 };
 
-void SOUND_pause_sequence(int32_t  /*sequence_num*/) {
-	if (unitTests)return;
+void SOUND_pause_sequence(int32_t /*sequence_num */ )
+{
+    if (unitTests)
+        return;
 #ifdef SOUND_SDLMIXER
-	Mix_PauseMusic();
-#endif//SOUND_SDLMIXER
+    Mix_PauseMusic();
+#endif                          //SOUND_SDLMIXER
 };
 
-void SOUND_stop_sequence(int32_t  /*sequence_num*/) {
-	if (unitTests)return;
+void SOUND_stop_sequence(int32_t /*sequence_num */ )
+{
+    if (unitTests)
+        return;
 #ifdef SOUND_SDLMIXER
-	Mix_HaltMusic();
-#endif//SOUND_SDLMIXER
+    Mix_HaltMusic();
+#endif                          //SOUND_SDLMIXER
 };
-void SOUND_resume_sequence(int32_t  /*sequence_num*/) {
-	if (unitTests)return;
+
+void SOUND_resume_sequence(int32_t /*sequence_num */ )
+{
+    if (unitTests)
+        return;
 #ifdef SOUND_SDLMIXER
-	Mix_ResumeMusic();
-#endif//SOUND_SDLMIXER
+    Mix_ResumeMusic();
+#endif                          //SOUND_SDLMIXER
 };
 
-void SOUND_set_sequence_volume(int32_t volume, int32_t  milliseconds) {
-	if (unitTests)return;
+void SOUND_set_sequence_volume(int32_t volume, int32_t milliseconds)
+{
+    if (unitTests)
+        return;
+    //Logger->info("SOUND_set_sequence_volume  vol {}  ms {}", volume, milliseconds);
 #ifdef SOUND_SDLMIXER
 #ifndef __linux__
-	if ((milliseconds > 0) && (volume == 0))
-	{
-		if (GAME_music[last_sequence_num])
-		{
-			double position = Mix_GetMusicPosition(GAME_music[last_sequence_num]);
-			if (position != 0)
-			{
-				Mix_FadeOutMusic(milliseconds);
-				Mix_SetMusicPosition(position);
-			}
-		}
-	}
-	else if ((milliseconds > 0) && (lastMusicVolume == 0))
-	{
-		if (GAME_music[last_sequence_num])
-		{
-			double position = Mix_GetMusicPosition(GAME_music[last_sequence_num]);
-			if (position != 0)
-			{
-				Mix_FadeInMusicPos(GAME_music[last_sequence_num], 1, milliseconds, position);
-			}
-		}
-	}
-	else
-#endif //__linux__
-		Mix_VolumeMusic(volume);
-	lastMusicVolume = volume;
-	if (milliseconds == 0)
-		settingsMusicVolume = volume;
-#endif//SOUND_SDLMIXER
+    if ((milliseconds > 0) && (volume == 0)) {
+        if (GAME_music[last_sequence_num]) {
+            double position = Mix_GetMusicPosition(GAME_music[last_sequence_num]);
+            if (position != 0) {
+                Mix_FadeOutMusic(milliseconds);
+                Mix_SetMusicPosition(position);
+            }
+        }
+    } else if ((milliseconds > 0) && (lastMusicVolume == 0)) {
+        if (GAME_music[last_sequence_num]) {
+            double position = Mix_GetMusicPosition(GAME_music[last_sequence_num]);
+            if (position != 0) {
+                Mix_FadeInMusicPos(GAME_music[last_sequence_num], 1, milliseconds, position);
+            }
+        }
+    } else
+#endif                          //__linux__
+        Mix_VolumeMusic(volume);
+    lastMusicVolume = volume;
+    if (milliseconds == 0)
+        settingsMusicVolume = volume;
+#endif                          //SOUND_SDLMIXER
 }
 
-void SOUND_init_MIDI_sequence(uint8_t*  /*datax*/, type_E3808_music_header* headerx, int32_t track_number)
+void SOUND_init_MIDI_sequence(uint8_t * /*datax */ , type_E3808_music_header *headerx,
+                              int32_t track_number)
 {
-	if (unitTests)return;
-	//uint8_t* acttrack = &header[32 + track_number * 32];
-	uint8_t* acttrack = headerx->str_8.track_10[track_number].xmiData_0;
-	//int testsize = *(uint32_t*)(&header[32 + (track_number + 1) * 32] + 18) - *(uint32_t*)(acttrack + 18);
-	int testsize2 = *(uint32_t*)(acttrack + 26);
-
-	//we can translate datax from xmi to mid and play(with bad quality or slow midi emulators), at now but we use ogg samples
-	//unsigned char* TranscodeXmiToMid(const unsigned char* pXmiData,	size_t iXmiLength, size_t* pMidLength);
-	size_t iXmiLength = testsize2;
-	size_t pMidLength;
-	dirsstruct helpdirsstruct;
-
-	if (oggmusic) {
-
-		std::string oggmusicPath = GetSubDirectoryPath(oggmusicFolder);
-		char alternativeMusicPath[512] = "";
-		char selectedTrackPath[512] = "";
-		//if (track_number > 1)track_number = 0;
-		if (oggmusicalternative)///&&track_number==4
-		{
-			if (track_number == 0)
-			{
-				sprintf(alternativeMusicPath, "%s/alternative/day", oggmusicPath.c_str());
-			}
-			else if (track_number == 1)
-			{
-				sprintf(alternativeMusicPath, "%s/alternative/night", oggmusicPath.c_str());
-			}
-			else if (track_number == 2)
-			{
-				sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
-			}
-			else if (track_number == 3)
-			{
-				sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
-			}
-			else if (track_number == 4)
-			{
-				sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
-			}
-			else if (track_number == 5)
-			{
-				sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
-			}
-			else
-			{
-				sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
-			}
-
-			helpdirsstruct = getListDir(alternativeMusicPath);
-
-			if (helpdirsstruct.number > 0)
-			{
-				int randtrack = rand()%(helpdirsstruct.number + 1);
-				if(randtrack==0)
-					sprintf(selectedTrackPath, "%s/music%d.ogg", oggmusicPath.c_str(), track_number);
-				else
-					sprintf(selectedTrackPath, "%s/%s", alternativeMusicPath ,helpdirsstruct.dir[randtrack-1]);
-			}
-			else
-				sprintf(selectedTrackPath, "%s/music%d.ogg", oggmusicPath.c_str(), track_number);
-		}
-		else
-			sprintf(selectedTrackPath, "%s/music%d.ogg", oggmusicPath.c_str(), track_number);
+    //Logger->info("SOUND_init_MIDI_sequence {}", track_number);
+    if (unitTests)
+        return;
+    //uint8_t* acttrack = &header[32 + track_number * 32];
+    uint8_t *acttrack = headerx->str_8.track_10[track_number].xmiData_0;
+    //int testsize = *(uint32_t*)(&header[32 + (track_number + 1) * 32] + 18) - *(uint32_t*)(acttrack + 18);
+    int testsize2 = *(uint32_t *) (acttrack + 26);
+
+    //we can translate datax from xmi to mid and play(with bad quality or slow midi emulators), at now but we use ogg samples
+    //unsigned char* TranscodeXmiToMid(const unsigned char* pXmiData,       size_t iXmiLength, size_t* pMidLength);
+    size_t iXmiLength = testsize2; // FIXME this size is completely bogus - between 0.8 and 1.2TB!!!
+    size_t pMidLength;
+    dirsstruct helpdirsstruct;
+
+    if (oggmusic) {
+
+        std::string oggmusicPath = GetSubDirectoryPath(oggmusicFolder);
+        // FIXME 1024bytes added to the stack
+        char alternativeMusicPath[512] = "";
+        char selectedTrackPath[512] = "";
+        //if (track_number > 1)track_number = 0;
+        if (oggmusicalternative)        ///&&track_number==4
+        {
+            if (track_number == 0) {
+                sprintf(alternativeMusicPath, "%s/alternative/day", oggmusicPath.c_str());
+            } else if (track_number == 1) {
+                sprintf(alternativeMusicPath, "%s/alternative/night", oggmusicPath.c_str());
+            } else if (track_number == 2) {
+                sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
+            } else if (track_number == 3) {
+                sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
+            } else if (track_number == 4) {
+                sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
+            } else if (track_number == 5) {
+                sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
+            } else {
+                sprintf(alternativeMusicPath, "%s/alternative/cave", oggmusicPath.c_str());
+            }
+
+            helpdirsstruct = getListDir(alternativeMusicPath);
+
+            if (helpdirsstruct.number > 0) {
+                int randtrack = rand() % (helpdirsstruct.number + 1);
+                if (randtrack == 0)
+                    sprintf(selectedTrackPath, "%s/music%d.ogg", oggmusicPath.c_str(),
+                            track_number);
+                else
+                    sprintf(selectedTrackPath, "%s/%s", alternativeMusicPath,
+                            helpdirsstruct.dir[randtrack - 1]);
+            } else
+                sprintf(selectedTrackPath, "%s/music%d.ogg", oggmusicPath.c_str(), track_number);
+        } else
+            sprintf(selectedTrackPath, "%s/music%d.ogg", oggmusicPath.c_str(), track_number);
 #ifdef SOUND_SDLMIXER
-		GAME_music[track_number] = Mix_LoadMUS(selectedTrackPath);
-#endif//SOUND_SDLMIXER
-	}
-	else
-	{
-		uint8_t* outmidi = TranscodeXmiToMid(/*(const uint8_t*)*(uint32_t*)(*/acttrack/* + 18)*/, iXmiLength, &pMidLength);
-		SDL_RWops* rwmidi = SDL_RWFromMem(outmidi, pMidLength);
-
-		//Timidity_Init();
+        GAME_music[track_number] = Mix_LoadMUS(selectedTrackPath);
+#endif                          //SOUND_SDLMIXER
+    } else {
+        uint8_t *outmidi =
+            TranscodeXmiToMid( /*(const uint8_t*)*(uint32_t*)( */ acttrack /* + 18) */ , iXmiLength,
+                              &pMidLength);
+        SDL_RWops *rwmidi = SDL_RWFromMem(outmidi, pMidLength);
+        //Logger->info("SOUND_init_MIDI_sequence  xmi {}  mid {}", iXmiLength, pMidLength);
+        //alsound_save_chunk(outmidi, pMidLength, NULL);
+        //Timidity_Init();
 #ifdef SOUND_SDLMIXER
-		GAME_music[track_number] = Mix_LoadMUSType_RW(rwmidi, MUS_MID, SDL_TRUE);
-#endif//SOUND_SDLMIXER
-		//music2 = Mix_LoadMUSType_RW(rwmidi, MIX_MUSIC_TIMIDITY, SDL_TRUE);
+        GAME_music[track_number] = Mix_LoadMUSType_RW(rwmidi, MUS_MID, SDL_TRUE); // FIXME
+#endif                          //SOUND_SDLMIXER
+        //music2 = Mix_LoadMUSType_RW(rwmidi, MIX_MUSIC_TIMIDITY, SDL_TRUE);
 
-	}
-#ifdef SOUND_OPENAL
-	/*if (!AL_inited)
-	{
-		//ALSOUND_init();
-		AL_inited = true;
-	}*/
-#endif//SOUND_OPENAL
+    }
 }
 
+void SOUND_start_speech(const uint8_t track, const uint16_t offset, const uint16_t len)
+{
+    size_t track_str_len;
+    char *track_filename = NULL;
+    uint8_t *track_data = NULL;
+    uint32_t track_data_len;
+    uint32_t track_offset;
+    int fd;
+    Mix_Chunk chunk = {};
+
+    //Logger->info("SOUND_start_speech  track {}  offset {}  len {}", track, offset, len);
+
+    std::string speech_path = GetSubDirectoryPath(speech_folder);
+    track_str_len = speech_path.length() + 13;
+
+    track_filename = (char *) calloc(track_str_len, sizeof(char));
+    if (!track_filename) {
+        return;
+    }
+
+    snprintf(track_filename, track_str_len, "%s/track%02d.cdr", speech_path.c_str(), track);
+    //Logger->info("track: {}", track_filename);
+
+    track_data_len = len * 2360;
+    track_offset = offset * 2360;
+    track_data = (uint8_t *) calloc(track_data_len, sizeof(uint8_t));
+    if (!track_data) {
+        goto cleanup_nofreedata;
+    }
+
+    if ((fd = open(track_filename, O_RDONLY)) < 0) {
+        Logger->warn("unable to open speech file {}", track_filename);
+        goto cleanup_nofreedata;
+    }
+
+    if (lseek(fd, track_offset, SEEK_SET) != track_offset) {
+        Logger->warn("wrong offset {} in speech file {}", track_offset, track_filename);
+        goto cleanup;
+    }
+
+    if (read(fd, track_data, track_data_len) == -1) {
+        Logger->warn("can't read speech file {}", track_filename);
+        goto cleanup;
+    }
+
+    chunk.allocated = 1;
+    chunk.alen = track_data_len;
+    chunk.abuf = track_data;
+    chunk.volume = 127;
+
+    //alsound_save_chunk(track_data, track_data_len, NULL);
 
+#ifdef SOUND_OPENAL
+    uint16_t format;
 
+    format = alsound_get_chunk_flags(OPENAL_CC_SZ - 1);
+    alsound_play(OPENAL_CC_SZ - 1, &chunk, nullptr, nullptr, format | AL_TYPE_SPEECH);
+    free(track_data);
 
-//Mix_Chunk mychunk;
+#elif defined (SOUND_SDLMIXER)
 
-/*bool load_sound_files()
-{
-	//Load the sound effects
-	scratch = Mix_LoadWAV("scratch.wav");
-	high = Mix_LoadWAV("high.wav");
-	med = Mix_LoadWAV("medium.wav");
-	low = Mix_LoadWAV("low.wav");
-
-	//If there was a problem loading the sound effects
-	if ((scratch == NULL) || (high == NULL) || (med == NULL) || (low == NULL))
-	{
-		return false;
-	}
-
-	//If everything loaded fine
-	return true;
-}*/
+    Mix_PlayChannel(-1, &chunk, 0);
+    // due to chunk.allocated == 1, track_data will be freed by sdlmixer once the chunk has been played
+
+#endif
+
+cleanup: 
+    close(fd);
+cleanup_nofreedata:
+    free(track_filename);
+}
 
 void clean_up_sound()
 {
-	if (unitTests)return;
-	/*//Free the sound effects
-	Mix_FreeChunk(scratch);
-	Mix_FreeChunk(high);
-	Mix_FreeChunk(med);
-	Mix_FreeChunk(low);*/
-
-	//Free the music
-	//Mix_FreeMusic(music);
+    if (unitTests)
+        return;
+
 #ifdef SOUND_SDLMIXER
-	for (int i = 0;i < 10;i++)
-	{
-		//Mix_FreeChunk(GAME_musicmp3[i]);
-		Mix_FreeMusic(GAME_music[i]);
-	}
-
-	//Quit SDL_mixer
-	Mix_CloseAudio();
-#endif//SOUND_SDLMIXER
-}
-/*
-int load_music_files() {
-	GAME_musicmp3[0] = Mix_LoadMUS("music.mp3");
-}*/
-/*
-int playsound1()
-{
-	//Play the scratch effect
-	if (Mix_PlayChannel(-1, scratch, 0) == -1)
-	{
-		return 1;
-	}
-	return 0;
-}
-int playsound2()
-{
-	//Play the scratch effect
-	if (Mix_PlayChannel(-1, high, 0) == -1)
-	{
-		return 1;
-	}
-	return 0;
-}
-int playsound3()
-{
-	//Play the scratch effect
-	if (Mix_PlayChannel(-1, med, 0) == -1)
-	{
-		return 1;
-	}
-	return 0;
-}
-int playsound4()
-{
-	//Play the scratch effect
-	if (Mix_PlayChannel(-1, low, 0) == -1)
-	{
-		return 1;
-	}
-	return 0;
-}
-*/
-/*
-void playmusic1()
-{
-	if (Mix_PlayingMusic() == 0)
-	{
-		//Play the music
-		if (Mix_PlayMusic(music, -1) == -1)
-			if (Mix_PausedMusic() == 1)
-			{
-				//Resume the music
-				Mix_ResumeMusic();
-			}
-		//If the music is playing
-			else
-			{
-				//Pause the music
-				Mix_PauseMusic();
-			}
-	}
-}
-*/
-/*
-void stopmusic1()
-{
-	Mix_HaltMusic();
+    for (int i = 0; i < 10; i++) {
+        Mix_FreeMusic(GAME_music[i]);
+    }
+
+    Mix_CloseAudio();
+#endif
 }
-*/
+
 void playmusic2(int32_t track_number)
 {
-	if (unitTests)return;
+    //Logger->info("playmusic2 {}", track_number);
+    if (unitTests)
+        return;
 #ifdef SOUND_SDLMIXER
-	if (Mix_PlayingMusic() == 0)
-	{
-		//Play the music
-		if (Mix_PlayMusic(GAME_music[track_number], -1) == -1)
-			if (Mix_PausedMusic() == 1)
-			{
-				//Resume the music
-				Mix_ResumeMusic();
-			}
-		//If the music is playing
-			else
-			{
-				//Pause the music
-				Mix_PauseMusic();
-			}
-	}
-#endif//SOUND_SDLMIXER
+    if (Mix_PlayingMusic() == 0) {
+        //Play the music
+        if (Mix_PlayMusic(GAME_music[track_number], -1) == -1)
+            if (Mix_PausedMusic() == 1) {
+                //Resume the music
+                Mix_ResumeMusic();
+            }
+        //If the music is playing
+            else {
+                //Pause the music
+                Mix_PauseMusic();
+            }
+    }
+#endif                          //SOUND_SDLMIXER
 }
 
 struct {
-	int a;
+    int a;
 } common_IO_configurations;
 
 struct {
-	int a;
+    int a;
 } environment_string;
 
-int32_t ac_sound_call_driver(AIL_DRIVER* drvr, int32_t fn, VDI_CALL* out) {
-	switch (fn) {
-	case 0x300: {//AIL_API_install_driver
-		drvr->VHDR_4->VDI_HDR_var10 = (void*)&common_IO_configurations;
-		drvr->VHDR_4->num_IO_configurations_14 = num_IO_configurations;
-		drvr->VHDR_4->environment_string_16 = environment_string.a;
-		drvr->VHDR_4->VDI_HDR_var46 = service_rate;
-		break;
-	}
-	case 0x301: {//AIL_API_install_DIG_driver_file/AIL_API_install_MDI_driver_file		
-		out->AX = 1;//offset
-		out->BX = 2;//offset
-		out->SI = 0;
-		out->DI = 0;
-		break;
-	}
-	case 0x304: {//AIL_API_install_DIG_driver_file/AIL_API_install_MDI_driver_file
-		break;
-	}
-	case 0x305: {//AIL_API_install_DIG_driver_file/AIL_API_install_MDI_driver_file
-		break;
-	}
-	case 0x306: {//AIL_API_uninstall_driver/AIL_API_uninstall_MDI_driver_file
-		break;
-	}
-	case 0x401: {
-		/*		mychunk.abuf=(uint8_t*)last_sample->start_2_3[0];
-				mychunk.alen = last_sample->len_4_5[0];
-				mychunk.volume = last_sample->volume_16;
-				//mychunk.allocated = 0;
-
-				#ifdef USE_SDL2
-						Mix_PlayChannel(-1, &mychunk, 0);
-				#else
-						Mix_PlayChannel(-1, &mychunk, 0);
-				#endif*/
-		break;
-	}
-	case 0x501: {//AIL_API_install_MDI_INI
-		break;
-	}
-	case 0x502: {//AIL_API_install_MDI_INI
-		break;
-	}
-	default:
-	{
-		break;
-	}
-	}
-	return 1;
+int32_t ac_sound_call_driver(AIL_DRIVER *drvr, int32_t fn, VDI_CALL *out)
+{
+    switch (fn) {
+    case 0x300:{               //AIL_API_install_driver
+            drvr->VHDR_4->VDI_HDR_var10 = (void *)&common_IO_configurations;
+            drvr->VHDR_4->num_IO_configurations_14 = num_IO_configurations;
+            drvr->VHDR_4->environment_string_16 = environment_string.a;
+            drvr->VHDR_4->VDI_HDR_var46 = service_rate;
+            break;
+        }
+    case 0x301:{               //AIL_API_install_DIG_driver_file/AIL_API_install_MDI_driver_file          
+            out->AX = 1;        //offset
+            out->BX = 2;        //offset
+            out->SI = 0;
+            out->DI = 0;
+            break;
+        }
+    case 0x304:{               //AIL_API_install_DIG_driver_file/AIL_API_install_MDI_driver_file
+            break;
+        }
+    case 0x305:{               //AIL_API_install_DIG_driver_file/AIL_API_install_MDI_driver_file
+            break;
+        }
+    case 0x306:{               //AIL_API_uninstall_driver/AIL_API_uninstall_MDI_driver_file
+            break;
+        }
+    case 0x401:{
+            /*              mychunk.abuf=(uint8_t*)last_sample->start_2_3[0];
+               mychunk.alen = last_sample->len_4_5[0];
+               mychunk.volume = last_sample->volume_16;
+               //mychunk.allocated = 0;
+
+               #ifdef USE_SDL2
+               Mix_PlayChannel(-1, &mychunk, 0);
+               #else
+               Mix_PlayChannel(-1, &mychunk, 0);
+               #endif */
+            break;
+        }
+    case 0x501:{               //AIL_API_install_MDI_INI
+            break;
+        }
+    case 0x502:{               //AIL_API_install_MDI_INI
+            break;
+        }
+    default:
+        {
+            break;
+        }
+    }
+    return 1;
 };
 
-void SOUND_set_master_volume(int32_t volume) {
-	//gamechunk[S->index_sample].volume = volume;
+void SOUND_set_master_volume(int32_t volume)
+{
 #ifdef SOUND_SDLMIXER
-	master_volume = volume;
+    master_volume = volume;
 
-	for (int i = 0; i < 32; i++)
-		Mix_Volume(i, (int)((gamechunk[i].volume * master_volume) / 127));
-#endif//SOUND_SDLMIXER
-
-	//may be can fix - must analyze
+    for (int i = 0; i < 32; i++)
+        Mix_Volume(i, (int)((gamechunk[i].volume * master_volume) / 127));
+#endif
 
+    //may be can fix - must analyze
 }
 
-void SOUND_set_sample_volume(HSAMPLE S, int32_t volume) {
-#ifdef SOUND_SDLMIXER
-	if (master_volume == -1)
-		master_volume = 127;
-	gamechunk[S->index_sample].volume = volume;
-	Mix_Volume(S->index_sample, (int)((gamechunk[S->index_sample].volume * master_volume) / 127));
-#endif//SOUND_SDLMIXER
+void SOUND_set_sample_volume(HSAMPLE S, int32_t volume)
+{
+#ifdef SOUND_OPENAL
+    //Logger->info("SOUND_set_sample_volume id {}  vol {}", S->id, volume);
+    alsound_set_sample_volume(S->id, volume);
+#elif defined(SOUND_SDLMIXER)
+    if (master_volume == -1)
+        master_volume = 127;
+    gamechunk[S->index_sample].volume = volume;
+    Mix_Volume(S->index_sample, (int)((gamechunk[S->index_sample].volume * master_volume) / 127));
+#endif                          //SOUND_SDLMIXER
 }
 
-void SOUND_start_sample(HSAMPLE S) {
-	if (unitTests)return;
-#ifdef SOUND_SDLMIXER
-	if (hqsound)
-	{
-		/*
-		// load sample.wav in to sample
-		uint8_t* presample = malloc(S->len_4_5[0] * 4 + 10);
-		Mix_Chunk* sample;
-		sample = Mix_LoadWAV_RW(presample, 0);
-		if (!sample) {
-			printf("Mix_LoadWAV_RW: %s\n", Mix_GetError());
-			// handle error
-		}
-		*/
-
-		//44100, AUDIO_S16, 2, 4096
-		//src/dst
-		/*SDL_AudioCVT cvt;
-		SDL_BuildAudioCVT(&cvt, AUDIO_U8, 1, S->playback_rate_15, AUDIO_S16, 2, 44100);
-		SDL_assert(cvt.needed); // obviously, this one is always needed.
-		cvt.len = S->len_4_5[0];// 1024 * 2 * 4;  // 1024 stereo float32 sample frames.
-		cvt.buf = (Uint8*)S->start_2_3[0];//(Uint8*)SDL_malloc(cvt.len * cvt.len_mult);
-		// read your float32 data into cvt.buf here.
-		SDL_ConvertAudio(&cvt);*/
-
-		gamechunk[S->index_sample].abuf = /*sample->abuf;//*/ (uint8_t*)S->start_44mhz;
-		if (fixspeedsound)
-			gamechunk[S->index_sample].alen = /*sample->alen;//*/S->len_4_5[0] * 16;
-		else
-			gamechunk[S->index_sample].alen = /*sample->alen;//*/S->len_4_5[0] * 8;
-			if (debug_first_sound) {
-				Logger->trace("SOUND_start_sample-hq:{}", S->start_44mhz);
-				debug_first_sound = false;
-			}
-	}
-	else
-	{
-		if (debug_first_sound) {
-			Logger->trace("SOUND_start_sample:{}", S->start_44mhz);
-			debug_first_sound = false;
-		}
-		gamechunk[S->index_sample].abuf = (uint8_t*)S->start_2_3[0];
-		gamechunk[S->index_sample].alen = S->len_4_5[0];
-	}
-	
-	gamechunk[S->index_sample].volume = S->volume_16;
-	gamechunkHSAMPLE[S->index_sample] = S;
-
-	Mix_PlayChannel(S->index_sample, &gamechunk[S->index_sample], 0);
-#endif//SOUND_SDLMIXER
+void SOUND_start_sample(HSAMPLE S)
+{
+    if (unitTests)
+        return;
+
 #ifdef SOUND_OPENAL
-	//sound_load_wav((char*)S->start_44mhz, sizeof(S->start_44mhz));
-	if (hqsound)
-	{
-		gamechunk[S->index_sample].abuf = (uint8_t*)S->start_44mhz;
-		gamechunk[S->index_sample].alen = S->len_4_5[0] * 4;
-	}
-	else
-	{
-		gamechunk[S->index_sample].abuf = (uint8_t*)S->start_2_3[0];
-		gamechunk[S->index_sample].alen = S->len_4_5[0];
-	}
-
-	gamechunk[S->index_sample].volume = S->volume_16;
-	gamechunkHSAMPLE[S->index_sample] = S;
-	ALSOUND_play(S->index_sample,&gamechunk[S->index_sample],0);
-#endif//SOUND_OPENAL
+    uint16_t format;
+
+    format = alsound_get_chunk_flags(S->id);
+
+    if (format & AL_FORMAT_STEREO8_22050) {
+        gamechunk[S->index_sample].abuf = (uint8_t *) S->wavbuff;
+        gamechunk[S->index_sample].alen = S->len_4_5[0] * 2;
+    } else {
+        gamechunk[S->index_sample].abuf = (uint8_t *) S->start_2_3[0];
+        gamechunk[S->index_sample].alen = S->len_4_5[0];
+    }
+    gamechunk[S->index_sample].volume = S->volume_16;
+    gamechunkHSAMPLE[S->index_sample] = S;
+
+    alsound_play(S->id, &gamechunk[S->index_sample], nullptr, nullptr, format);
+
+    //alsound_update();
+#elif defined (SOUND_SDLMIXER)
+    if (hqsound) {
+        gamechunk[S->index_sample].abuf = /*sample->abuf;// */ (uint8_t *) S->start_44mhz;
+        if (fixspeedsound)
+            gamechunk[S->index_sample].alen = /*sample->alen;// */ S->len_4_5[0] * 16;
+        else
+            gamechunk[S->index_sample].alen = /*sample->alen;// */ S->len_4_5[0] * 8;
+        if (debug_first_sound) {
+            Logger->trace("SOUND_start_sample-hq:{}", S->start_44mhz);
+            debug_first_sound = false;
+        }
+    } else {
+        if (debug_first_sound) {
+            Logger->trace("SOUND_start_sample:{}", S->start_44mhz);
+            debug_first_sound = false;
+        }
+        gamechunk[S->index_sample].abuf = (uint8_t *) S->start_2_3[0];
+        gamechunk[S->index_sample].alen = S->len_4_5[0];
+    }
+
+    gamechunk[S->index_sample].volume = S->volume_16;
+    gamechunkHSAMPLE[S->index_sample] = S;
+
+    //alsound_save_chunk(gamechunk[S->index_sample].abuf, gamechunk[S->index_sample].alen, NULL);
+
+    Mix_PlayChannel(S->index_sample, &gamechunk[S->index_sample], 0);
+#endif
 };
 
-uint32_t SOUND_sample_status(HSAMPLE S) {
-	if (unitTests)return 0;
-#ifdef SOUND_SDLMIXER
-	if (Mix_Playing(S->index_sample)==0)return 2;
-#endif//SOUND_SDLMIXER
+uint32_t SOUND_sample_status(HSAMPLE S)
+{
+    if (unitTests)
+        return 0;
+
 #ifdef SOUND_OPENAL
-	return 2;
-#endif//SOUND_SDLMIXER
-	return 0;
+    if (alsound_sample_status(S->id) == 0) {
+        return 2;
+    }
+#elif defined(SOUND_SDLMIXER)
+    if (Mix_Playing(S->index_sample) == 0)
+        return 2;
+#endif                          //SOUND_SDLMIXER
+    return 0;
 }
 
-void SOUND_end_sample(HSAMPLE  /*S*/) {
-#ifdef SOUND_SDLMIXER
-	Mix_HaltChannel(-1);
-#endif//SOUND_SDLMIXER
+void SOUND_end_sample(HSAMPLE S)
+{
+
+#ifdef SOUND_OPENAL
+    //Logger->info("SOUND_end_sample {} {}", S->id, S->len_4_5[0] * 2);
+    alsound_end_sample(S->id);
+#elif defined(SOUND_SDLMIXER)
+    Mix_HaltChannel(-1);
+#endif                          //SOUND_SDLMIXER
 };
 
-void SOUND_finalize(int channel) {
-	HSAMPLE S = gamechunkHSAMPLE[channel];
-	if (S)
-	{
-		if (S->status_1 != 1)
-		{
-			if (S->status_1 != 2)
-			{
-				S->status_1 = 2;
-			}
-		}
-		S->vol_scale_18[0][0] = 0;
-		S->flags_14 = 0;
-		S->vol_scale_18[0][2] = 0;
-		S->vol_scale_18[0][3] = 0;
-	}
+void SOUND_finalize(int channel)
+{
+    HSAMPLE S = gamechunkHSAMPLE[channel];
+    if (S) {
+        if (S->status_1 != 1) {
+            if (S->status_1 != 2) {
+                S->status_1 = 2;
+            }
+        }
+        S->vol_scale_18[0][0] = 0;
+        S->flags_14 = 0;
+        S->vol_scale_18[0][2] = 0;
+        S->vol_scale_18[0][3] = 0;
+    }
 }
 
-int run();
-
 bool init_sound()
 {
-	//run();
-	//#define MUSIC_MID_FLUIDSYNTH
-	//Initialize SDL_mixer
-	srand(time(NULL));
+    //#define MUSIC_MID_FLUIDSYNTH
+    srand(time(NULL));
 #ifdef SOUND_SDLMIXER
-	if (hqsound) {
-		if (Mix_OpenAudio(44100, AUDIO_S16, 2, 4096) == -1)//4096
-		//if (Mix_OpenAudio(44100, AUDIO_S16, 2, 4096) == -1)//4096
-		//if (Mix_OpenAudio(11025, AUDIO_S8, 1, 4096) == -1)//4096
-		{
-			return false;
-		}
-	}
-	else
-	{
-		if (Mix_OpenAudio(22050, AUDIO_U8/*MIX_DEFAULT_FORMAT*/, 2, 4096) == -1)//4096
-		//if (Mix_OpenAudio(11025/*22050*/, AUDIO_U8/*MIX_DEFAULT_FORMAT*/, 1, 4096) == -1)//4096
-		{
-			return false;
-		}
-	}
-
-	//Mix_SetSoundFonts("c:\\prenos\\Magic2\\sf2\\TOM-SF2.sf2");
-	//load_sound_files();
-	/*if(mp3music)
-		load_music_files();*/
-	/*
-Mix_HookMusicFinished(void (SDLCALL *music_finished)(void));
-*/
-	Mix_ChannelFinished(SOUND_finalize);
-#endif//SOUND_SDLMIXER
+    if (hqsound) {
+        if (Mix_OpenAudio(44100, AUDIO_S16, 2, 4096) == -1)     //4096
+            //if (Mix_OpenAudio(44100, AUDIO_S16, 2, 4096) == -1)//4096
+            //if (Mix_OpenAudio(11025, AUDIO_S8, 1, 4096) == -1)//4096
+        {
+            return false;
+        }
+    } else {
+        if (Mix_OpenAudio(22050, AUDIO_U8 /*MIX_DEFAULT_FORMAT */ , 2, 4096) == -1)     //4096
+            //if (Mix_OpenAudio(11025/*22050*/, AUDIO_U8/*MIX_DEFAULT_FORMAT*/, 1, 4096) == -1)//4096
+        {
+            return false;
+        }
+    }
+
+    //Mix_SetSoundFonts("c:\\prenos\\Magic2\\sf2\\TOM-SF2.sf2");
+    //Mix_SetSoundFonts("touhou.sf2");
+    //load_sound_files();
+    /*if(mp3music)
+       load_music_files(); */
+    /*
+       Mix_HookMusicFinished(void (SDLCALL *music_finished)(void));
+     */
+    Mix_ChannelFinished(SOUND_finalize);
+#endif
 #ifdef SOUND_OPENAL
-	if (hqsound) {
-		ALSOUND_init();
-	}
-	else
-	{
-		ALSOUND_init();
-	}
-
-#endif//SOUND_OPENAL
-	return true;
+    alsound_init();
+#endif
+    return true;
 }
 
-AIL_DRIVER* ac_AIL_API_install_driver(int  /*a1*/, uint8_t*  /*a2*/, int  /*a3*/)/*driver_image,n_bytes*///27f720
+AIL_DRIVER *ac_AIL_API_install_driver(int /*a1 */ , uint8_t * /*a2 */ , int /*a3 */ )   /*driver_image,n_bytes *///27f720
 {
 
-
-	//printf("drvr:%08X, fn:%08X, in:%08X, out:%08X\n", drvr, fn, in, out);
-	return 0;
+    //printf("drvr:%08X, fn:%08X, in:%08X, out:%08X\n", drvr, fn, in, out);
+    return 0;
 }
 
 uint16_t actvect[4096];
 
 void ac_set_real_vect(uint32_t vectnum, uint16_t real_ptr)
 {
-	actvect[vectnum] = real_ptr;
-	//66
+    actvect[vectnum] = real_ptr;
+    //66
 };
 
 uint16_t ac_get_real_vect(uint32_t vectnum)
 {
-	return actvect[vectnum];
+    return actvect[vectnum];
 };
 
-void test_music()
+void SOUND_UPDATE()
 {
-}
-
-void my_audio_callback(void *midi_player, uint8_t *stream, int len);
-
-/* variable declarations */
-static uint32_t is_playing = 0; /* remaining length of the sample we have to play */
-static short buffer[4096]; /* Audio buffer */
-
-int run()
-{
-	/* local variables */
-	static SDL_AudioSpec            spec; /* the specs of our piece of music */
-	static struct ADL_MIDIPlayer    *midi_player = NULL; /* Instance of ADLMIDI player */
-	static const char               *music_path = NULL; /* Path to music file */
-
-	music_path = "c:\\prenos\\remc2\\remc2\\memimages\\midi\\Music001.mid";
-
-	/* Initialize SDL.*/
-	if (SDL_Init(SDL_INIT_AUDIO) < 0)
-		return 1;
-
-	spec.freq = 44100;
-	spec.format = AUDIO_S16SYS;
-	spec.channels = 2;
-	spec.samples = 2048;
-
-	/* Initialize ADLMIDI */
-	midi_player = adl_init(spec.freq);
-	if (!midi_player)
-	{
-		fprintf(stderr, "Couldn't initialize ADLMIDI: %s\n", adl_errorString());
-		return 1;
-	}
-
-	/* set the callback function */
-	spec.callback = my_audio_callback;
-	/* set ADLMIDI's descriptor as userdata to use it for sound generation */
-	spec.userdata = midi_player;
-
-	/* Open the audio device */
-	if (SDL_OpenAudio(&spec, NULL) < 0)
-	{
-		fprintf(stderr, "Couldn't open audio: %s\n", SDL_GetError());
-		return 1;
-	}
-
-	/* Optionally Setup ADLMIDI as you want */
-
-	/* Set using of embedded bank by ID */
-	/*adl_setBank(midi_player, 68);*/
-
-	/* Set using of custom bank (WOPL format) loaded from a file */
-	/*adl_openBankFile(midi_player, "/home/vitaly/Yandex.Disk/??????/Wolfinstein.wopl");*/
-
-	/* Open the MIDI (or MUS, IMF or CMF) file to play */
-	if (adl_openFile(midi_player, music_path) < 0)
-	{
-		fprintf(stderr, "Couldn't open music file: %s\n", adl_errorInfo(midi_player));
-		SDL_CloseAudio();
-		adl_close(midi_player);
-		return 1;
-	}
-
-	is_playing = 1;
-	/* Start playing */
-	SDL_PauseAudio(0);
-
-	Logger->info("Playing... Hit Ctrl+C to quit!");
-
-	/* wait until we're don't playing */
-	while (is_playing)
-	{
-		SDL_Delay(100);
-	}
-
-	/* shut everything down */
-	SDL_CloseAudio();
-	adl_close(midi_player);
-
-	return 0;
-}
-
-/*
- audio callback function
- here you have to copy the data of your audio buffer into the
- requesting audio buffer (stream)
- you should only copy as much as the requested length (len)
-*/
-void my_audio_callback(void *midi_player, uint8_t *stream, int len)
-{
-	struct ADL_MIDIPlayer* p = (struct ADL_MIDIPlayer*)midi_player;
-
-	/* Convert bytes length into total count of samples in all channels */
-	int samples_count = len / 2;
-
-	/* Take some samples from the ADLMIDI */
-	samples_count = adl_play(p, samples_count, (short*)buffer);
-
-	if (samples_count <= 0)
-	{
-		is_playing = 0;
-		SDL_memset(stream, 0, len);
-		return;
-	}
-
-	/* Send buffer to the audio device */
-	SDL_memcpy(stream, (uint8_t*)buffer, samples_count * 2);
-}
-
-#define TEST_ERROR(_msg)		\
-	error = alGetError();		\
-	if (error != AL_NO_ERROR) {	\
-		fprintf(stderr, _msg "\n");	\
-		return;		\
-	}
-//------------------
-
-void SOUND_UPDATE() {
-#ifdef SOUND_OPENAL
-	for (int i = 0; i < 32; i++)
-	{
-		if (source_state[i] == AL_PLAYING)
-		{
-			alGetSourcei(alSource[i], AL_SOURCE_STATE, &source_state[i]);
-			//TEST_ERROR("source state get");
-		}
-		else
-		{
-			alDeleteSources(1, &alSource[i]);
-			alDeleteBuffers(1, &alSampleSet[i]);
-		}
-	}
-	/*while (source_state == AL_PLAYING) {
-		alGetSourcei(alSource, AL_SOURCE_STATE, &source_state);
-		TEST_ERROR("source state get");
-	}*/
-#endif//SOUND_OPENAL
-};
-
-
 #ifdef SOUND_OPENAL
-ALCcontext* context;
-ALCdevice* device;
-const ALCchar* defaultDeviceName;
-ALCenum error;
-
-static void list_audio_devices(const ALCchar* devices)
-{
-	const ALCchar* device = devices, * next = devices + 1;
-	size_t len = 0;
-
-	fprintf(stdout, "Devices list:\n");
-	fprintf(stdout, "----------\n");
-	while (device && *device != '\0' && next && *next != '\0') {
-		fprintf(stdout, "%s\n", device);
-		len = strlen(device);
-		device += (len + 1);
-		next += (len + 2);
-	}
-	fprintf(stdout, "----------\n");
-}
-void ALSOUND_init()
-{
-	ALboolean enumeration;
-	const ALCchar* devices;
-	//const ALCchar* defaultDeviceName = argv[1];
-	int ret;
-#ifdef LIBAUDIO
-	WaveInfo* wave;
-#endif
-	char* bufferData;
-	ALCdevice* device;
-	ALvoid* data;
-	ALCcontext* context;
-	ALsizei size, freq;
-	ALenum format;
-	//ALuint buffer, source;
-	ALfloat listenerOri[] = { 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f };
-	ALboolean loop = AL_FALSE;
-
-	//fprintf(stdout, "Using " BACKEND " as audio backend\n");
-
-	enumeration = alcIsExtensionPresent(NULL, "ALC_ENUMERATION_EXT");
-	if (enumeration == AL_FALSE)
-		fprintf(stderr, "enumeration extension not available\n");
-
-	list_audio_devices(alcGetString(NULL, ALC_DEVICE_SPECIFIER));
-
-	//if (!defaultDeviceName)
-	defaultDeviceName = alcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
-
-	device = alcOpenDevice(defaultDeviceName);
-	if (!device) {
-		fprintf(stderr, "unable to open default device\n");
-		return;
-	}
-
-	fprintf(stdout, "Device: %s\n", alcGetString(device, ALC_DEVICE_SPECIFIER));
-
-	alGetError();
-
-	context = alcCreateContext(device, NULL);
-	if (!alcMakeContextCurrent(context)) {
-		fprintf(stderr, "failed to make default context\n");
-		return;
-	}
-	TEST_ERROR("make default context");
-
-	/* set orientation */
-	alListener3f(AL_POSITION, 0, 0, 1.0f);
-	TEST_ERROR("listener position");
-	alListener3f(AL_VELOCITY, 0, 0, 0);
-	TEST_ERROR("listener velocity");
-	alListenerfv(AL_ORIENTATION, listenerOri);
-	TEST_ERROR("listener orientation");
-	/*
-	for (int i = 0; i < 32; i++)
-	{
-		alGenSources((ALuint)1, &alSource[i]);
-		TEST_ERROR("source generation");
-
-		alSourcef(alSource[i], AL_PITCH, 1);
-		TEST_ERROR("source pitch");
-		alSourcef(alSource[i], AL_GAIN, 1);
-		TEST_ERROR("source gain");
-		alSource3f(alSource[i], AL_POSITION, 0, 0, 0);
-		TEST_ERROR("source position");
-		alSource3f(alSource[i], AL_VELOCITY, 0, 0, 0);
-		TEST_ERROR("source velocity");
-		alSourcei(alSource[i], AL_LOOPING, AL_FALSE);
-		TEST_ERROR("source looping");
-
-		alGenBuffers(1, &alSampleSet[i]);
-		TEST_ERROR("buffer generation");
-	}*/
-}
-
-ALenum alFormatBuffer = AL_FORMAT_MONO16/*AL_FORMAT_MONO16*/;    //buffer format
-ALsizei alFreqBuffer = 44100;       //frequency
-//ALint source_state;
-/*void ALSOUND_load_wav(char* alBuffer,long alBufferLen)
-{
-	//Now for the second part, loading a wav file.You have to open a file, fill buffers with dataand then attach it to a source.
-
-	//char* alBuffer;             //data for the buffer
-	
-	//long       alBufferLen;        //bit depth
-	//ALboolean    alLoop;         //loop
-
-
-	//load the wave file
-	//alutLoadWAVFile("my_music.wav", alFormatBuffer, (void**) alBuffer, (unsigned int*) alBufferLen, alFreqBuffer);//, alLoop);
-
-	//create a source
-	alGenSources(1, &alSource);
-
-	//create  buffer
-	alGenBuffers(1, &alSampleSet);
-
-	//put the data into our sampleset buffer
-	alBufferData(alSampleSet, alFormatBuffer, alBuffer, alBufferLen, alFreqBuffer);
-
-	//assign the buffer to this source
-	alSourcei(alSource, AL_BUFFER, alSampleSet);
-
-	//release the data
-	//alutUnloadWAV(alFormatBuffer, alBuffer, alBufferLen, alFreqBuffer);
-}*/
-void ALSOUND_play(int which, Mix_Chunk* mixchunk, int loops)
-{
-	/*
-	//Once the sound is loaded we can play it.To do this we use alSourcePlay.
-
-	alSourcei(alSource, AL_LOOPING, AL_TRUE);
-
-	//play
-	alSourcePlay(alSource);
-
-	//alSourcePlay(source);
-
-	//to stop
-	//alSourceStop(alSource);
-	*/
-	/*
-	alSourcePlay(): Play, replay, or resume a source.
-	alSourceStop(): Stop one or more sources.
-	alSourceRewind(): Rewind a source (set the playback position to the beginning).
-	alSourcePause(): Pause a source.
-	*/
-	//alutLoadWAVFile("test.wav", &format, &data, &size, &freq, &loop);
-	//TEST_ERROR("loading wav file");
-	
-	//----
-	//delete
-	//alDeleteSources(1, &alSource);
-	//delete our buffer
-	//alDeleteBuffers(1, &alSampleSet);
-    //----
-	alGenSources((ALuint)1, &alSource[which]);
-	TEST_ERROR("source generation");
-
-	alSourcef(alSource[which], AL_PITCH, 1);
-	TEST_ERROR("source pitch");
-	alSourcef(alSource[which], AL_GAIN, 1);
-	TEST_ERROR("source gain");
-	alSource3f(alSource[which], AL_POSITION, 0, 0, 0);
-	TEST_ERROR("source position");
-	alSource3f(alSource[which], AL_VELOCITY, 0, 0, 0);
-	TEST_ERROR("source velocity");
-	alSourcei(alSource[which], AL_LOOPING, AL_FALSE);
-	TEST_ERROR("source looping");
-
-	alGenBuffers(1, &alSampleSet[which]);
-	TEST_ERROR("buffer generation");
-	//------
-
-
-	alBufferData(alSampleSet[which], alFormatBuffer, mixchunk->abuf, mixchunk->alen, alFreqBuffer);
-	TEST_ERROR("buffer copy");
-
-	alSourcei(alSource[which], AL_BUFFER, alSampleSet[which]);
-	TEST_ERROR("buffer binding");
-
-	alSourcePlay(alSource[which]);
-	TEST_ERROR("source playing");
-
-	alGetSourcei(alSource[which], AL_SOURCE_STATE, &source_state[which]);
-	TEST_ERROR("source state get");
-	/*while (source_state == AL_PLAYING) {
-		alGetSourcei(alSource, AL_SOURCE_STATE, &source_state);
-		TEST_ERROR("source state get");
-	}
-
-	alDeleteSources(1, &alSource);
-	alDeleteBuffers(1, &alSampleSet);*/
-}
-
-void ALSOUND_delete()
-{
-	//Once you�ve finished don�t forget to clean memoryand release OpenAL contextand device
-
-	//alDeleteSources(1, &alSource);
-
-	//delete our buffer
-	//alDeleteBuffers(1, &alSampleSet);
-
-	context = alcGetCurrentContext();
-
-	//Get device for active context
-	device = alcGetContextsDevice(context);
-
-	//Disable context
-	alcMakeContextCurrent(NULL);
-
-	//Release context(s)
-	alcDestroyContext(context);
-
-	//Close device
-	alcCloseDevice(device);
-}
-
-
-/*#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <stdint.h>
-#include <inttypes.h>
-#include <unistd.h>
-#include <stdbool.h>
-
-#include <AL/al.h>
-#include <AL/alc.h>
-*/
-/*
-#ifdef LIBAUDIO
-#include <audio/wave.h>
-#define BACKEND	"libaudio"
-#else
-#include <AL/alut.h>
-#define BACKEND "alut"
+    alsound_update();
 #endif
-*/
-
-
-
-	
-static inline ALenum to_al_format(short channels, short samples)
-{
-	bool stereo = (channels > 1);
-
-	switch (samples) {
-	case 16:
-		if (stereo)
-			return AL_FORMAT_STEREO16;
-		else
-			return AL_FORMAT_MONO16;
-	case 8:
-		if (stereo)
-			return AL_FORMAT_STEREO8;
-		else
-			return AL_FORMAT_MONO8;
-	default:
-		return -1;
-	}
-}
-#endif//SOUND_OPENAL
-/*
-int main(int argc, char** argv)
-{
-	ALboolean enumeration;
-	const ALCchar* devices;
-	const ALCchar* defaultDeviceName = argv[1];
-	int ret;
-#ifdef LIBAUDIO
-	WaveInfo* wave;
-#endif
-	char* bufferData;
-	ALCdevice* device;
-	ALvoid* data;
-	ALCcontext* context;
-	ALsizei size, freq;
-	ALenum format;
-	ALuint buffer, source;
-	ALfloat listenerOri[] = { 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f };
-	ALboolean loop = AL_FALSE;
-	ALCenum error;
-	ALint source_state;
-
-	//fprintf(stdout, "Using " BACKEND " as audio backend\n");
-
-	enumeration = alcIsExtensionPresent(NULL, "ALC_ENUMERATION_EXT");
-	if (enumeration == AL_FALSE)
-		fprintf(stderr, "enumeration extension not available\n");
-
-	list_audio_devices(alcGetString(NULL, ALC_DEVICE_SPECIFIER));
-
-	if (!defaultDeviceName)
-		defaultDeviceName = alcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
-
-	device = alcOpenDevice(defaultDeviceName);
-	if (!device) {
-		fprintf(stderr, "unable to open default device\n");
-		return -1;
-	}
-
-	fprintf(stdout, "Device: %s\n", alcGetString(device, ALC_DEVICE_SPECIFIER));
-
-	alGetError();
-
-	context = alcCreateContext(device, NULL);
-	if (!alcMakeContextCurrent(context)) {
-		fprintf(stderr, "failed to make default context\n");
-		return -1;
-	}
-	TEST_ERROR("make default context");
-
-	alListener3f(AL_POSITION, 0, 0, 1.0f);
-	TEST_ERROR("listener position");
-	alListener3f(AL_VELOCITY, 0, 0, 0);
-	TEST_ERROR("listener velocity");
-	alListenerfv(AL_ORIENTATION, listenerOri);
-	TEST_ERROR("listener orientation");
-
-	alGenSources((ALuint)1, &source);
-	TEST_ERROR("source generation");
-
-	alSourcef(source, AL_PITCH, 1);
-	TEST_ERROR("source pitch");
-	alSourcef(source, AL_GAIN, 1);
-	TEST_ERROR("source gain");
-	alSource3f(source, AL_POSITION, 0, 0, 0);
-	TEST_ERROR("source position");
-	alSource3f(source, AL_VELOCITY, 0, 0, 0);
-	TEST_ERROR("source velocity");
-	alSourcei(source, AL_LOOPING, AL_FALSE);
-	TEST_ERROR("source looping");
-
-	alGenBuffers(1, &buffer);
-	TEST_ERROR("buffer generation");
-
-#ifdef LIBAUDIO
-	wave = WaveOpenFileForReading("test.wav");
-	if (!wave) {
-		fprintf(stderr, "failed to read wave file\n");
-		return -1;
-	}
-
-	ret = WaveSeekFile(0, wave);
-	if (ret) {
-		fprintf(stderr, "failed to seek wave file\n");
-		return -1;
-	}
-
-	bufferData = malloc(wave->dataSize);
-	if (!bufferData) {
-		perror("malloc");
-		return -1;
-	}
-
-	ret = WaveReadFile(bufferData, wave->dataSize, wave);
-	if (ret != wave->dataSize) {
-		fprintf(stderr, "short read: %d, want: %d\n", ret, wave->dataSize);
-		return -1;
-	}
-
-	alBufferData(buffer, to_al_format(wave->channels, wave->bitsPerSample),
-		bufferData, wave->dataSize, wave->sampleRate);
-	TEST_ERROR("failed to load buffer data");
-#else
-	//alutLoadWAVFile("test.wav", &format, &data, &size, &freq, &loop);
-	TEST_ERROR("loading wav file");
-
-	alBufferData(buffer, format, data, size, freq);
-	TEST_ERROR("buffer copy");
-#endif
-
-	alSourcei(source, AL_BUFFER, buffer);
-	TEST_ERROR("buffer binding");
-
-	alSourcePlay(source);
-	TEST_ERROR("source playing");
-
-	alGetSourcei(source, AL_SOURCE_STATE, &source_state);
-	TEST_ERROR("source state get");
-	while (source_state == AL_PLAYING) {
-		alGetSourcei(source, AL_SOURCE_STATE, &source_state);
-		TEST_ERROR("source state get");
-	}
-
-	alDeleteSources(1, &source);
-	alDeleteBuffers(1, &buffer);
-	device = alcGetContextsDevice(context);
-	alcMakeContextCurrent(NULL);
-	alcDestroyContext(context);
-	alcCloseDevice(device);
-
-	return 0;
-}
-*/
+};
diff --git a/remc2/portability/port_sdl_sound.h b/remc2/portability/port_sdl_sound.h
index 9bcefb1ad..8768da2bc 100644
--- a/remc2/portability/port_sdl_sound.h
+++ b/remc2/portability/port_sdl_sound.h
@@ -2,140 +2,121 @@
 #ifndef PORT_SDL_SOUND_H
 #define PORT_SDL_SOUND_H
 
-//#define SOUND_OPENAL
+#define SOUND_OPENAL
 
 #include "mctypes.h"
 
 #define SOUND_SDLMIXER
 
 #ifdef _MSC_VER
-	#include "SDL.h"
+#include "SDL.h"
 #ifdef SOUND_SDLMIXER
-	#include "SDL_mixer_ext.h"
-	#include "music.h"
-	#include "mixer.h"
+#include "SDL_mixer_ext.h"
+#include "music.h"
+#include "mixer.h"
 #endif
 #else
-    #include "SDL2/SDL.h"
+#include "SDL2/SDL.h"
 #ifdef SOUND_SDLMIXER
-	#include "SDL2/SDL_mixer.h"
+#include "SDL2/SDL_mixer.h"
 #endif
 #endif
 
-#ifdef SOUND_OPENAL
-	#include <al.h>
-	#include <alc.h>
-#endif//SOUND_OPENAL
-
 //#include "music_timidity.h"
 #include "xmi2mid.h"
-#include <time.h>       /* time */
+#include <time.h>               /* time */
 #include <string>
 
 #include "../engine/ail_sound.h"
 #include "port_filesystem.h"
 
 #pragma pack (1)
-typedef struct {//lenght 32 - this is may be format of wav sound file
-	uint8_t* wavData_0;//data of wav//18
-	int8_t stub_4[4];//22
-	int32_t wavSize_8;//24
-	int16_t word_12;//28
-	int8_t filename_14[18];//first 18 chars - name//30
-}
-sub2type_E37A0_sound_buffer2;
-
-typedef struct {//lenght 2072
-	int8_t stub[10];
-	sub2type_E37A0_sound_buffer2 wavs_10[96];
-}
-sub1type_E37A0_sound_buffer2;
-
-typedef struct {//lenght 3100
-	int8_t byte_0;
-	int8_t byte_1;
-	int8_t byte_2;
-	int8_t byte_3;
-	int8_t byte_4;
-	int8_t byte_5;
-	int8_t byte_6;
-	int8_t byte_7;
-	sub1type_E37A0_sound_buffer2 str_8;//2072 lenght
-	int8_t next_str[10];
-}
-type_E37A0_sound_buffer2;
+typedef struct {                //length 32
+    int8_t filename_14[18];
+    uint8_t *wavData_0;
+    int8_t stub_4[4];
+    int32_t wavSize_8;
+    int16_t word_12;
+} sub2type_E37A0_sound_buffer2;
+
+typedef struct {                //length 3072
+    sub2type_E37A0_sound_buffer2 wavs_10[96];
+} sub1type_E37A0_sound_buffer2;
+
+typedef struct {                //length 3090
+    int8_t byte_0;
+    int8_t byte_1;
+    int8_t byte_2;
+    int8_t byte_3;
+    int8_t byte_4;
+    int8_t byte_5;
+    int8_t byte_6;
+    int8_t byte_7;
+    sub1type_E37A0_sound_buffer2 str_8; //3072 length
+    int8_t next_str[10];
+} type_E37A0_sound_buffer2;
 
 //shadow type_E37A0_sound_buffer2
-typedef struct {//lenght 32 - this is may be format of wav sound file
-	int32_t wavData_0;//data of wav//18
-	int8_t stub_4[4];//22
-	int32_t wavSize_8;//24
-	int16_t word_12;//28
-	int8_t filename_14[18];//first 18 chars - name//30
-}
-shadow_sub2type_E37A0_sound_buffer2;
-
-typedef struct {//lenght 2072
-	int8_t stub[10];
-	shadow_sub2type_E37A0_sound_buffer2 wavs_10[96];
-}
-shadow_sub1type_E37A0_sound_buffer2;
-
-typedef struct {//lenght 3100
-	int8_t byte_0;
-	int8_t byte_1;
-	int8_t byte_2;
-	int8_t byte_3;
-	int8_t byte_4;
-	int8_t byte_5;
-	int8_t byte_6;
-	int8_t byte_7;
-	shadow_sub1type_E37A0_sound_buffer2 str_8;//2072 lenght
-	int8_t next_str[10];
-}
-shadow_type_E37A0_sound_buffer2;
+typedef struct {                //length 32
+    int8_t filename_14[18];
+    int32_t wavData_0;
+    int8_t stub_4[4];
+    int32_t wavSize_8;
+    int16_t word_12;
+} shadow_sub2type_E37A0_sound_buffer2;
+
+typedef struct {                //length 3072
+    shadow_sub2type_E37A0_sound_buffer2 wavs_10[96];
+} shadow_sub1type_E37A0_sound_buffer2;
+
+typedef struct {                //length 3090
+    int8_t byte_0;
+    int8_t byte_1;
+    int8_t byte_2;
+    int8_t byte_3;
+    int8_t byte_4;
+    int8_t byte_5;
+    int8_t byte_6;
+    int8_t byte_7;
+    shadow_sub1type_E37A0_sound_buffer2 str_8;  //3072 length
+    int8_t next_str[10];
+} shadow_type_E37A0_sound_buffer2;
 //shadow type_E37A0_sound_buffer2
 
-typedef struct {//lenght 16*6=96
-	int32_t dword_0;
-	int32_t dword_4;
-	int32_t sizeBytes_8;
-	int32_t dword_12;
-}
-type_v8;
-
-
-
-typedef struct {//lenght 32 - this is may be format of wav sound file
-	uint8_t* xmiData_0;//data of wav//18
-	int8_t stub_4[4];//22
-	int32_t xmiSize_8;//24
-	int16_t word_12;//28
-	int8_t filename_14[18];//first 18 chars - name//30
-}
-sub2type_E3808_music_header;
-
-typedef struct {//lenght 216
-	int8_t stub[10];
-	sub2type_E3808_music_header track_10[6];
-	int8_t stubb[14];
-}
-sub1type_E3808_music_header;
-
-typedef struct {//lenght 224
-	int8_t byte_0;
-	int8_t byte_1;
-	int8_t byte_2;
-	int8_t byte_3;
-	int8_t byte_4;
-	int8_t byte_5;
-	int8_t byte_6;
-	int8_t byte_7;
-	sub1type_E3808_music_header str_8;//216 lenght
-}
-type_E3808_music_header;
+typedef struct {                //length 16*6=96
+    int32_t dword_0;
+    int32_t dword_4;
+    int32_t sizeBytes_8;
+    int32_t dword_12;
+} type_v8;
+
+typedef struct {                //length 32 - this is may be format of wav sound file
+    uint8_t *xmiData_0;         //data of wav//18
+    int8_t stub_4[4];           //22
+    int32_t xmiSize_8;          //24
+    int16_t word_12;            //28
+    int8_t filename_14[18];     //first 18 chars - name//30
+} sub2type_E3808_music_header;
+
+typedef struct {                //length 216
+    int8_t stub[10];
+    sub2type_E3808_music_header track_10[6];
+    int8_t stubb[14];
+} sub1type_E3808_music_header;
+
+typedef struct {                //length 224
+    int8_t byte_0;
+    int8_t byte_1;
+    int8_t byte_2;
+    int8_t byte_3;
+    int8_t byte_4;
+    int8_t byte_5;
+    int8_t byte_6;
+    int8_t byte_7;
+    sub1type_E3808_music_header str_8;  //216 length
+} type_E3808_music_header;
 /*
-typedef struct {//lenght 80656
+typedef struct {//length 80656
 	int8_t byte_0;
 	int8_t byte_1;
 	int8_t byte_2;
@@ -149,45 +130,43 @@ typedef struct {//lenght 80656
 type_E3810_music_data;*/
 
 //shadow shadow_type_E3808_music_header
-typedef struct {//lenght 32 - this is may be format of wav sound file
-	int32_t xmiData_0;//data of wav//18
-	int8_t stub_4[4];//22
-	int32_t xmiSize_8;//24
-	int16_t word_12;//28
-	int8_t filename_14[18];//first 18 chars - name//30
-}
-shadow_sub2type_E3808_music_header;
-
-typedef struct {//lenght 216
-	int8_t stub[10];
-	shadow_sub2type_E3808_music_header track_10[6];
-	int8_t stubb[14];
-}
-shadow_sub1type_E3808_music_header;
-
-typedef struct {//lenght 224
-	int8_t byte_0;
-	int8_t byte_1;
-	int8_t byte_2;
-	int8_t byte_3;
-	int8_t byte_4;
-	int8_t byte_5;
-	int8_t byte_6;
-	int8_t byte_7;
-	shadow_sub1type_E3808_music_header str_8;//216 lenght
-}
-shadow_type_E3808_music_header;
+typedef struct {                //length 32 - this is may be format of wav sound file
+    int32_t xmiData_0;          //data of wav//18
+    int8_t stub_4[4];           //22
+    int32_t xmiSize_8;          //24
+    int16_t word_12;            //28
+    int8_t filename_14[18];     //first 18 chars - name//30
+} shadow_sub2type_E3808_music_header;
+
+typedef struct {                //length 216
+    int8_t stub[10];
+    shadow_sub2type_E3808_music_header track_10[6];
+    int8_t stubb[14];
+} shadow_sub1type_E3808_music_header;
+
+typedef struct {                //length 224
+    int8_t byte_0;
+    int8_t byte_1;
+    int8_t byte_2;
+    int8_t byte_3;
+    int8_t byte_4;
+    int8_t byte_5;
+    int8_t byte_6;
+    int8_t byte_7;
+    shadow_sub1type_E3808_music_header str_8;   //216 length
+} shadow_type_E3808_music_header;
 //shadow shadow_type_E3808_music_header
 #pragma pack (16)
 
+// Mix_Chunk is defined in SDL_mixer.h
 #ifndef SOUND_SDLMIXER
 typedef struct {
-	int allocated;
-	Uint8* abuf;
-	Uint32 alen;
-	Uint8 volume;       /* Per-sample volume, 0-128 */
+    int allocated;
+    Uint8 *abuf;
+    Uint32 alen;
+    Uint8 volume;               /* Per-sample volume, 0-128 */
 } Mix_Chunk;
-#endif//SOUND_SDLMIXER
+#endif                          //SOUND_SDLMIXER
 
 #define USE_SDL2
 
@@ -198,6 +177,7 @@ extern bool hqsound;
 extern bool oggmusic;
 extern char oggmusicFolder[512];
 extern bool oggmusicalternative;
+extern char speech_folder[512];
 extern bool fixspeedsound;
 
 bool init_sound();
@@ -214,13 +194,14 @@ void playmusic2(int32_t track_number);
 extern uint8_t sound_buffer[4][20000];
 //extern HSAMPLE last_sample;
 
-int32_t ac_sound_call_driver(AIL_DRIVER* drvr, int32_t fn, VDI_CALL* out);
+int32_t ac_sound_call_driver(AIL_DRIVER * drvr, int32_t fn, VDI_CALL * out);
 
 void ac_set_real_vect(uint32_t vectnum, uint16_t real_ptr);
 uint16_t ac_get_real_vect(uint32_t vectnum);
-AIL_DRIVER* ac_AIL_API_install_driver(int a1, uint8_t* a2, int a3);
+AIL_DRIVER *ac_AIL_API_install_driver(int a1, uint8_t * a2, int a3);
 
-void SOUND_init_MIDI_sequence(uint8_t* datax, type_E3808_music_header* headerx, int32_t track_number);
+void SOUND_init_MIDI_sequence(uint8_t * datax, type_E3808_music_header * headerx,
+                              int32_t track_number);
 
 void SOUND_start_sample(HSAMPLE S);
 void SOUND_end_sample(HSAMPLE S);
@@ -232,17 +213,11 @@ void SOUND_resume_sequence(int32_t sequence_num);
 uint32_t SOUND_sample_status(HSAMPLE S);
 
 void SOUND_set_sample_volume(HSAMPLE S, int32_t volume);
-void SOUND_set_sequence_volume(int32_t volume, int32_t  milliseconds);
+void SOUND_set_sequence_volume(int32_t volume, int32_t milliseconds);
 void SOUND_set_master_volume(int32_t volume);
 void SOUND_UPDATE();
-//void test_midi_play(uint8_t* data, uint8_t* header, int32_t track_number);
-#ifdef SOUND_OPENAL
-//void ALSOUND_load_wav(char* alBuffer, long alBufferLen);
-void ALSOUND_play(int which, Mix_Chunk* chunk, int loops);
-void ALSOUND_init();
-#endif//SOUND_OPENAL
-
-
 
+void SOUND_start_speech(const uint8_t track, const uint16_t offset, const uint16_t len);
+//void test_midi_play(uint8_t* data, uint8_t* header, int32_t track_number);
 
-#endif //PORT_SDL_SOUND
\ No newline at end of file
+#endif                          //PORT_SDL_SOUND
diff --git a/remc2/portability/port_sdl_vga_mouse.h b/remc2/portability/port_sdl_vga_mouse.h
index 4a8bd246d..e6d74e8d3 100644
--- a/remc2/portability/port_sdl_vga_mouse.h
+++ b/remc2/portability/port_sdl_vga_mouse.h
@@ -18,12 +18,6 @@
 #include "port_sdl_sound.h"
 #include "port_filesystem.h"
 
-#define  SCENE_PREAMBLE_MENU  0x1
-#define         SCENE_FLIGHT  0x2
-#define    SCENE_FLIGHT_MENU  0x3
-#define     SCENE_SPELL_MENU  0x4
-#define           SCENE_DEAD  0x5
-
 typedef struct
 {
 	int32_t x;
diff --git a/remc2/portability/port_sound_lut.h b/remc2/portability/port_sound_lut.h
new file mode 100644
index 000000000..7a926938b
--- /dev/null
+++ b/remc2/portability/port_sound_lut.h
@@ -0,0 +1,522 @@
+#pragma once
+#ifndef PORT_SOUND_LUT_H
+#define PORT_SOUND_LUT_H
+
+struct al_chunk_table {
+    uint8_t flags;              // sound format, type, extra options 
+    int8_t ff_fx;               // force-feedback effect id
+};
+typedef struct al_chunk_table al_ct_t;
+
+const al_ct_t alct[3][70] = {
+    {                           // day
+     {0, -1},                    // id_0 -
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_1 OCEAN.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_2 WIND.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_3 EXPLOD3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_4 GAINMANA.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_5 FIRE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_6 ALLY.WAV
+     {0, -1},                    // id_7 NULL.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_8 DRAGROAR.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_9 FIREBAL1.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_QUAKE},        // id_10 QUAKE4.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_11 FOOLMANA.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_12 BEE1.WAV
+     {0, -1},                    // id_13 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_14 SELECT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_15 FIREBAL2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_16 DIE.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_17 HYDRA.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_18 GETSPELL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_19 SPEEDUP.WAV
+     {0, -1},                    // id_20 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_21 PORTMAKE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_22 PORTUSE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_23 LITNING.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_24 EXPLOD3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_25 HEAL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_26 CLANG.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_27 SPLASH2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_28 REBOUND.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_29 CANTUSE.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_METEOR},        // id_30 METEOREX.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_31 MARKET.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_32 SPIDER.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_33 ARROW1.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_34 ARROW2.WAV
+     {0, -1},                    // id_35 NULL.WAV
+     {0, -1},                    // id_36 NULL.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_37 CYMERIAN.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_38 DEEPONE.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_39 WYVERN.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_40 MANASHOT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_41 SWITCH.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_42 DEVIL.WAV
+     {0, -1},                    // id_43 NULL.WAV
+     {0, -1},                    // id_44 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_45 FIRE.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1}, // id_46 GOAT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_47 DOORC2.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_48 MWORM3.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_TORNADO},        // id_49 TORNADO.WAV
+     {0, -1},                    // id_50 NULL.WAV
+     {0, -1},                    // id_51 NULL.WAV
+     {0, -1},                    // id_52 NULL.WAV
+     {0, -1},                    // id_53 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_54 HIT1.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_55 HIT2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_56 HIT3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_57 HIT4.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_58 MADDOG.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_59 MDWELLER.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_60 MORPH.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_61 SUCCESS2.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_62 ZOMBIE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_63 SPELLUP.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_64 GWELL.WAV
+     {0, -1},                    // id_65 -
+     {0, -1},                    // id_66 -
+     {0, -1},                    // id_67 -
+     {0, -1},                    // id_68 -
+     {0, -1}                     // id_69 -
+     },
+    {                           // night
+     {0, -1},                    // id_0 -
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_1 OCEAN.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_2 CRICKET2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_3 EXPLOD3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_4 GAINMANA.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_5 FIRE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_6 ALLY.WAV
+     {0, -1},                    // id_7 NULL.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_8 DRAGROAR.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_9 FIREBAL1.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_QUAKE},        // id_10 QUAKE4.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_11 FOOLMANA.WAV
+     {0, -1},                    // id_12 NULL.WAV
+     {0, -1},                    // id_13 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_14 SELECT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_15 FIREBAL2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_16 DIE.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_17 HYDRA.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_18 GETSPELL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_19 SPEEDUP.WAV
+     {0, -1},                    // id_20 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_21 PORTMAKE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_22 PORTUSE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_23 LITNING.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_24 EXPLOD3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_25 HEAL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_26 CLANG.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_27 SPLASH2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_28 REBOUND.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_29 CANTUSE.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_METEOR},        // id_30 METEOREX.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_31 MARKET.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_32 SPIDER.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_33 ARROW1.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_34 ARROW2.WAV
+     {0, -1},                    // id_35 NULL.WAV
+     {0, -1},                    // id_36 NULL.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_37 CYMERIAN.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_38 DEEPONE.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_39 WYVERN.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_40 MANASHOT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_41 SWITCH.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_42 DEVIL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_43 FIREFLY1.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_44 FIREFLY2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_45 FIRE.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1}, // id_46 GOAT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_47 DOORC2.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_48 MWORM3.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_TORNADO},        // id_49 TORNADO.WAV
+     {0, -1},                    // id_50 NULL.WAV
+     {0, -1},                    // id_51 NULL.WAV
+     {0, -1},                    // id_52 NULL.WAV
+     {0, -1},                    // id_53 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_54 HIT1.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_55 HIT2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_56 HIT3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_57 HIT4.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_58 MADDOG.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_59 MDWELLER.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_60 MORPH.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_61 SUCCESS2.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_62 ZOMBIE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_63 SPELLUP.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_64 GWELL.WAV
+     {0, -1},                    // id_65 -
+     {0, -1},                    // id_66 -
+     {0, -1},                    // id_67 -
+     {0, -1},                    // id_68 -
+     {0, -1}                     // id_69 -
+     },
+    {                           // cave
+     {0, -1},                    // id_0 -
+     {0, -1},                    // id_1 NULL.WAV
+     {0, -1},                    // id_2 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_3 EXPLOD3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_4 GAINMANA.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_5 FIRE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_6 ALLY.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_7 CAVEMAN.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_8 DRAGROAR.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_9 FIREBAL1.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_QUAKE},        // id_10 QUAKE4.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_11 FOOLMANA.WAV
+     {0, -1},                    // id_12 NULL.WAV
+     {0, -1},                    // id_13 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_14 SELECT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_15 FIREBAL2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_16 DIE.WAV
+     {0, -1},                    // id_17 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_18 GETSPELL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_19 SPEEDUP.WAV
+     {0, -1},                    // id_20 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_21 PORTMAKE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_22 PORTUSE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_23 LITNING.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_24 EXPLOD3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_25 HEAL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_26 CLANG.WAV
+     {0, -1},                    // id_27 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_28 REBOUND.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_29 CANTUSE.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_METEOR},        // id_30 METEOREX.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_31 MARKET.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_32 SPIDER.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_33 ARROW1.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_34 ARROW2.WAV
+     {0, -1},                    // id_35 NULL.WAV
+     {0, -1},                    // id_36 NULL.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_37 CYMERIAN.WAV
+     {0, -1},                    // id_38 NULL.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1}, // id_39 WYVERN.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_40 MANASHOT.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_41 SWITCH.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_42 DEVIL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_43 FIREFLY1.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_44 FIREFLY2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_45 FIRE.WAV
+     {0, -1},                    // id_46 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_47 DOORC2.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_48 MWORM3.WAV
+     {AL_FORMAT_MONO8_22050, GP_HAPTIC_TORNADO},        // id_49 TORNADO.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_50 GLOOP1.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_51 GLOOP2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_52 GLOOP3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_53 GLOOP4.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_54 HIT1.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_55 HIT2.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_56 HIT3.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_57 HIT4.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_58 MADDOG.WAV
+     {0, -1},                    // id_59 NULL.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_60 MORPH.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_61 SUCCESS2.WAV
+     {AL_FORMAT_MONO8_22050 | AL_IGNORE_RECODE, -1},        // id_62 ZOMBIE.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_63 SPELLUP.WAV
+     {AL_FORMAT_MONO8_22050, -1},        // id_64 GWELL.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_65 DRIP1.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_66 DRIP2.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_67 DRIP3.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1},        // id_68 DRIP4.WAV
+     {AL_FORMAT_STEREO8_22050 | AL_TYPE_ENV, -1} // id_69 DRIP5.WAV
+     }
+};
+
+
+const char alct_name[3][70][9] = {
+    { // day
+        "null",
+        "ocean",
+        "wind",
+        "explod3",
+        "gainmana",
+        "fire",
+        "ally",
+        "null",
+        "dragroar",
+        "firebal1",
+        "quake4",
+        "foolmana",
+        "bee1",
+        "null",
+        "select",
+        "firebal2",
+        "die",
+        "hydra",
+        "getspell",
+        "speedup",
+        "null",
+        "portmake",
+        "portuse",
+        "litning",
+        "explod3",
+        "heal",
+        "clang",
+        "splash2",
+        "rebound",
+        "cantuse",
+        "meteorex",
+        "market",
+        "spider",
+        "arrow1",
+        "arrow2",
+        "null",
+        "null",
+        "cymerian",
+        "deepone",
+        "wyvern",
+        "manashot",
+        "switch",
+        "devil",
+        "null",
+        "null",
+        "fire",
+        "goat",
+        "doorc2",
+        "mworm3",
+        "tornado",
+        "null",
+        "null",
+        "null",
+        "null",
+        "hit1",
+        "hit2",
+        "hit3",
+        "hit4",
+        "maddog",
+        "mdweller",
+        "morph",
+        "success2",
+        "zombie",
+        "spellup",
+        "gwell",
+        "null",
+        "null",
+        "null",
+        "null",
+        "null"
+    },
+    { // night
+        "null",
+        "ocean",
+        "cricket2",
+        "explod3",
+        "gainmana",
+        "fire",
+        "ally",
+        "null",
+        "dragroar",
+        "firebal1",
+        "quake4",
+        "foolmana",
+        "null",
+        "null",
+        "select",
+        "firebal2",
+        "die",
+        "hydra",
+        "getspell",
+        "speedup",
+        "null",
+        "portmake",
+        "portuse",
+        "litning",
+        "explod3",
+        "heal",
+        "clang",
+        "splash2",
+        "rebound",
+        "cantuse",
+        "meteorex",
+        "market",
+        "spider",
+        "arrow1",
+        "arrow2",
+        "null",
+        "null",
+        "cymerian",
+        "deepone",
+        "wyvern",
+        "manashot",
+        "switch",
+        "devil",
+        "firefly1",
+        "firefly2",
+        "fire",
+        "goat",
+        "doorc2",
+        "mworm3",
+        "tornado",
+        "null",
+        "null",
+        "null",
+        "null",
+        "hit1",
+        "hit2",
+        "hit3",
+        "hit4",
+        "maddog",
+        "mdweller",
+        "morph",
+        "success2",
+        "zombie",
+        "spellup",
+        "gwell",
+        "null",
+        "null",
+        "null",
+        "null",
+        "null"
+    },
+    { // cave
+        "null",
+        "null",
+        "null",
+        "explod3",
+        "gainmana",
+        "fire",
+        "ally",
+        "caveman",
+        "dragroar",
+        "firebal1",
+        "quake4",
+        "foolmana",
+        "null",
+        "null",
+        "select",
+        "firebal2",
+        "die",
+        "null",
+        "getspell",
+        "speedup",
+        "null",
+        "portmake",
+        "portuse",
+        "litning",
+        "explod3",
+        "heal",
+        "clang",
+        "null",
+        "rebound",
+        "cantuse",
+        "meteorex",
+        "market",
+        "spider",
+        "arrow1",
+        "arrow2",
+        "null",
+        "null",
+        "cymerian",
+        "null",
+        "wyvern",
+        "manashot",
+        "switch",
+        "devil",
+        "firefly1",
+        "firefly2",
+        "fire",
+        "null",
+        "doorc2",
+        "mworm3",
+        "tornado",
+        "gloop1",
+        "gloop2",
+        "gloop3",
+        "gloop4",
+        "hit1",
+        "hit2",
+        "hit3",
+        "hit4",
+        "maddog",
+        "null",
+        "morph",
+        "success2",
+        "zombie",
+        "spellup",
+        "gwell",
+        "drip1",
+        "drip2",
+        "drip3",
+        "drip4",
+        "drip5"
+    }
+};
+
+struct al_creature_table {
+    uint8_t flags;              // sound-related options
+    int16_t chunk_id;           // chunk identifier to play
+};
+typedef struct al_creature_table al_crt_t;
+
+const al_crt_t alcrt[29] = {
+    {0, 8}, // 0 dragons
+    {AL_REPLAY_RARELY | AL_WHISPER, 46}, // 1 goat
+    {0, 12}, // 2 bee
+    {0, 8}, // 3 worms
+    {0, -1}, // 4 archer - creature is silent
+    {0, -1}, // 5 -
+    {0, -1}, // 6 -
+    {0, -1}, // 7 -
+    {0, -1}, // 8 -
+    {0, -1}, // 9 skeleton
+    {0, -1}, // 10 vissuluth - creature is normally silent
+    {0, -1}, // 11 -
+    {0, -1}, // 12 builder
+    {0, -1}, // 13 townie
+    {0, -1}, // 14 trader
+    {0, -1}, // 15 castle archer  - it's sound sample is in sync with him shooting, so don't schedule
+    {AL_POWERFUL_SHOUT, 39}, // 16 wyvern
+    {AL_POWERFUL_SHOUT, 58}, // 17 manticore
+    {0, -1}, // 18 sentinel - this creature is quiet afaict
+    {AL_WHISPER, 44}, // 19 firefly
+    {0, 32}, // 20 spider
+    {0, 42}, // 21 devil
+    {0, 48}, // 22 mana worm
+    {0, 59}, // 23 moon dweller
+    {0, 7}, // 24 troglodyte
+    {0, 37}, // 25 cymmerian
+    {AL_WHISPER, 62}, // 26 zombie
+    {AL_POWERFUL_SHOUT, 17}, // 27 hydra
+    {0, -1}, // 28 leviathan - it has a syncronized attack/sound pattern, so don't schedule
+};
+
+const char creature_name[29][16] = {
+    "dragon",        // 0
+    "goat",          // 1
+    "bee",           // 2
+    "worm",          // 3
+    "archer",        // 4
+    "unknown",       // 5
+    "unknown",       // 6
+    "unknown",       // 7
+    "unknown",       // 8
+    "skeleton",      // 9
+    "vissuluth",     // 10
+    "unknown",       // 11
+    "builder",       // 12
+    "townie",        // 13
+    "trader",        // 14
+    "castle archer", // 15
+    "wyvern",        // 16
+    "manticore",     // 17
+    "sentinel",      // 18
+    "firefly",       // 19
+    "spider",        // 20
+    "devil",         // 21
+    "mana worm",     // 22
+    "moon dweller",  // 23
+    "troglodyte",    // 24
+    "cymmerian",     // 25
+    "zombie",       // 26
+    "hydra",         // 27
+    "leviathan",     // 28
+};
+
+
+
+#endif
diff --git a/remc2/sub_main.cpp b/remc2/sub_main.cpp
index 6e1b94c4f..6f7452f66 100644
--- a/remc2/sub_main.cpp
+++ b/remc2/sub_main.cpp
@@ -4312,15 +4312,14 @@ char* off_DB06C[5] = { (char*)"I",(char*)"II",(char*)"III",(char*)"IV",(char*)"V
 
 #pragma pack (1)
 typedef struct {//lenght 4
-	int16_t word_0;
-	int16_t word_2;
-}
-type_sub_BYTE_DB080;
+	int16_t offset;
+	int16_t length;
+} track_chunk_t;
 
 typedef struct {//lenght 42
-	int8_t word_0;
+	int8_t track;
 	//int8_t stub;
-	type_sub_BYTE_DB080 str_sub_BYTE_DB080[10];
+	track_chunk_t chunk[10];
 }
 type_BYTE_DB080;
 #pragma pack (16)
@@ -4666,7 +4665,7 @@ char x_BYTE_E29F0 = 0; // weak
 char x_BYTE_E29F1 = 0; // weak
 char x_BYTE_E2A20 = 0; // weak
 uint8_t* x_WORD_E2A24 = 0; // weak
-char x_BYTE_E2A28_speek = 0; // weak
+char x_BYTE_E2A28_speek = 1; // weak
 
 //int x_DWORD_E36C4 = 0; // weak//50
 //little fix
@@ -13340,6 +13339,15 @@ void sub_1A970_change_game_settings(char a1, int a2, int a3)//1fb970
 		return;
 	}
 }
+
+void disable_speech(void)
+{
+    x_BYTE_E2A28_speek = 0;
+    x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 &= ~0x40;
+    x_D41A0_BYTEARRAY_4_struct.dwordindex_188 &= ~0x08;
+    x_D41A0_BYTEARRAY_4_struct.dwordindex_192 &= ~0x08;
+}
+
 // D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
 // D41A4: using guessed type int x_DWORD_D41A4;
 // D41A8: using guessed type char *off_D41A8;
@@ -38470,6 +38478,18 @@ void intervalsave(int index) {
 	SaveLevel_55080(0, x_D41A0_BYTEARRAY_4_struct.levelnumber_43w, outname);
 };
 
+#ifdef SOUND_OPENAL
+void set_listener_location(void)
+{
+    if (x_DWORD_EA3E4 != nullptr && x_DWORD_EA3E4[D41A0_0.array_0x2BDE[D41A0_0.LevelIndex_0xc].word_0x00a_2BE4_11240] != nullptr) {
+        int16_t index = D41A0_0.array_0x2BDE[D41A0_0.LevelIndex_0xc].word_0x00e_2BDE_11244 + 1;
+        axis_3d player_coord = D41A0_0.array_0x2BDE[D41A0_0.LevelIndex_0xc].struct_0x1d1_2BDE_11695[index].axis_2BDE_11695;
+        axis_4d player_rot = D41A0_0.array_0x2BDE[D41A0_0.LevelIndex_0xc].struct_0x1d1_2BDE_11695[index].rotation__2BDE_11701;
+        alsound_set_location(&player_coord, &player_rot);
+    }
+}
+#endif
+
 //long debugcounter_47560_2=0;
 //----- (00047560) --------------------------------------------------------
 void DrawAndEventsInGame_47560(/*uint8_t* a1, int a2, */uint32_t a3, signed int a4, __int16 a5)//228560
@@ -38600,6 +38620,10 @@ void DrawAndEventsInGame_47560(/*uint8_t* a1, int a2, */uint32_t a3, signed int
 	sub_6FEC0();
 	x_D41A0_BYTEARRAY_4_struct.byteindex_196 = x_DWORD_17DB54_game_turn2;
 
+#ifdef SOUND_OPENAL
+    set_listener_location();
+#endif
+
 	if (x_D41A0_BYTEARRAY_4_struct.byteindex_51 >= 3u)
 		sub_40F80();
 }
@@ -40838,6 +40862,10 @@ type_event_0x6E8E* NewEvent_4A050()//22b050
 		D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->dword_0xA4_164x = unk_F42B0x;
 		D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->byte_0x43_67 = 10;
 		D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->byte_0x39_57 = -6;
+		D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->play_ch = -1;
+        D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->play_mark = 0;
+        D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->dist_mark = UINT64_MAX;
+        D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->dist = UINT32_MAX;
 		D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->byte_0x3E_62 = D41A0_0.pointers_0x246[D41A0_0.dword_0x35] - D41A0_0.struct_0x6E8E;
 		D41A0_0.pointers_0x246[D41A0_0.dword_0x35]->rand_0x14_20 = D41A0_0.pointers_0x246[D41A0_0.dword_0x35] - D41A0_0.struct_0x6E8E + D41A0_0.rand_0x8;//this is it line
 		return D41A0_0.pointers_0x246[D41A0_0.dword_0x35--];
@@ -40864,6 +40892,10 @@ type_event_0x6E8E* NewEvent_4A050()//22b050
 		D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->dword_0xA4_164x = unk_F42B0x;
 		D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->byte_0x43_67 = 10;
 		D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->byte_0x39_57 = -6;
+		D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->play_ch = -1;
+        D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->play_mark = 0;
+        D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->dist_mark = UINT64_MAX;
+        D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->dist = UINT32_MAX;
 		D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->byte_0x3E_62 = D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6] - D41A0_0.struct_0x6E8E;
 		D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6]->rand_0x14_20 = D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6] - D41A0_0.struct_0x6E8E + D41A0_0.rand_0x8;//this is it line
 		return D41A0_0.dword_0x11EA[D41A0_0.dword_0x11e6--];
@@ -53054,7 +53086,8 @@ int sub_main(int argc, char** argv, char**  /*envp*/)//236F70
 		spdlog::level::level_enum level = spdlog::level::info;
 
 #ifdef _DEBUG
-		level = GetLoggingLevelFromString("Debug");
+		// why is there an ini file to set this option?
+		//level = GetLoggingLevelFromString("Debug");
 #else
 		level = GetLoggingLevelFromString(loggingLevel.c_str());
 #endif
@@ -54295,8 +54328,14 @@ void UpdateEntities_57730()//238730
 				}
 				continue;
 			case 0x5:
-				if (jx->life_0x8 < 0)
-					continue;
+				if (jx->life_0x8 < 0) {
+                    //Logger->error("UpdateEntities_57730 death of class 5 id {}  ch {}", jx->id_0x1A_26, jx->play_ch);
+                    if (jx->play_ch > -1) {
+                        alsound_delete_source(jx->play_ch);
+                        jx->play_ch = -1;
+                    }
+                    continue;
+                }
 				if (jx->state_0x45_69 < 0xE8)
 				{
 					v8 = (jx->state_0x45_69==0xB4);
@@ -58210,7 +58249,6 @@ void sub_5C800(type_event_0x6E8E* a1x, char a2)//23d800
 	{
 		//result = (short)x_D41A0_BYTEARRAY_4;
 		x_D41A0_BYTEARRAY_4_struct.byteindex_180 = a2;
-		set_scene(SCENE_DEAD);
 	}
 	//return result;
 }
@@ -59344,6 +59382,7 @@ void AddPlayer03_00_5E010(type_event_0x6E8E* a1x)//23f010
 		a1x->state_0x45_69 = 2;
 		a1x->word_0x2C_44 = 0;
 		PrepareEventSound_6E450(a1x - D41A0_0.struct_0x6E8E, -1, 16);
+		set_scene(SCENE_DEAD);
 	}
 }
 
@@ -76569,7 +76608,7 @@ void sub_86BD0_freemem1()//267bd0
 //		result = sub_85F00_free_memory(x_DWORD_E2A6C);//264CDC - 266070
 	/*if (x_DWORD_E2A70)
 		result = sub_85F00_free_memory(x_DWORD_E2A70);*/
-	x_BYTE_E2A28_speek = 0;
+	//x_BYTE_E2A28_speek = 0;
 	//x_DWORD_E2A6C = 0;
 	//x_DWORD_E2A70 = 0;
 	//return result;
@@ -76595,18 +76634,18 @@ void sub_86EB0(unsigned __int8 a1, unsigned __int8 a2, char a3)//267eb0
 
 	//v3 = 42 * a1;
 	//v4 = x_BYTE_DB080[v3];
-	v4 = str_BYTE_DB080[a1].word_0;
+	v4 = str_BYTE_DB080[a1].track;
 	/*v5 = 4 * a2 + v3;
 	v6 = *(__int16*)((char*)&x_BYTE_DB080[2] + v5);
 	v7 = *(__int16*)((char*)&x_BYTE_DB080[4] + v5);*/
-	v6 = str_BYTE_DB080[a1].str_sub_BYTE_DB080[a2].word_0;
-	v7 = str_BYTE_DB080[a1].str_sub_BYTE_DB080[a2].word_2;
-	if (v4 && v7)
-	{
-		if (a3)
-			sub_86F70_sound_proc12(v4, v6, v7);
-		else
-			sub_86FF0(v4, v6, v7);
+	v6 = str_BYTE_DB080[a1].chunk[a2].offset;
+	v7 = str_BYTE_DB080[a1].chunk[a2].length;
+	if (v4 && v7) {
+		SOUND_start_speech(v4, v6, v7);
+		//if (a3)
+		//	sub_86F70_sound_proc12(v4, v6, v7);
+		//else
+		//	sub_86FF0(v4, v6, v7);
 	}
 }
 // DB082: using guessed type __int16 x_WORD_DB082[];
@@ -76625,9 +76664,9 @@ void sub_86F20(char a1)//267f20
 	/*v3 = *(int16_t*)&x_BYTE_DB080[2 + v1 * 2];
 	v4 = *(int16_t*)&x_BYTE_DB080[4 + v1 * 2];*/
 	v1 = ((a1 != 0) + 25);
-	v2 = str_BYTE_DB080[v1].word_0;
-	v3 = str_BYTE_DB080[v1].str_sub_BYTE_DB080[0].word_0;
-	v4 = str_BYTE_DB080[v1].str_sub_BYTE_DB080[0].word_2;
+	v2 = str_BYTE_DB080[v1].track;
+	v3 = str_BYTE_DB080[v1].chunk[0].offset;
+	v4 = str_BYTE_DB080[v1].chunk[0].length;
 	if (v2)
 	{
 		if (v4)
diff --git a/remc2/sub_main.h b/remc2/sub_main.h
index 1a6ad1514..ce5da0a89 100644
--- a/remc2/sub_main.h
+++ b/remc2/sub_main.h
@@ -651,4 +651,6 @@ void initposistruct();
 void Initialize();
 int /*__cdecl*/ sub_main(int argc, char **argv, char **envp);
 
+void disable_speech(void);
+
 #endif //SUB_MAIN_ACTIVE
